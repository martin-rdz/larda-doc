

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyLARDA.SpectraProcessing &mdash; pyLARDA  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home" alt="Documentation Home"> pyLARDA
          

          
          </a>

          
            
            
              <div class="version">
                3.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how_to_use.html">How to use larda</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../datacontainer_and_transformation.html">Data container and transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../guide_config.html">Guide to config-files</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../setup_remote.html">Setup remote date source</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../peakTree.html">peakTree extension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../spectra.html">SpectraProcessing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_overview.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Contributors</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">pyLARDA</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../pyLARDA.html">pyLARDA</a> &raquo;</li>
        
      <li>pyLARDA.SpectraProcessing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyLARDA.SpectraProcessing</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This routine calculates the radar moments for the RPG 94 GHz FMCW radar &#39;LIMRAD94&#39; and generates a NetCDF4 file.</span>
<span class="sd">The generated files can be used as input for the Cloudnet processing chain.</span>

<span class="sd">Args:</span>
<span class="sd">    **date (string): format YYYYMMDD</span>
<span class="sd">    **path (string): path where NetCDF file will be stored</span>

<span class="sd">Example:</span>

<span class="sd">    .. code::</span>

<span class="sd">        python spec2mom_limrad94.py date=20181201 path=/tmp/pycharm_project_626/scripts_Willi/cloudnet_input/</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">bisect</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">tqdm.auto</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">CubicSpline</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">correlate</span>

<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;../../larda/&#39;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">pyLARDA.helpers</span> <span class="kn">import</span> <span class="n">z2lin</span><span class="p">,</span> <span class="n">argnearest</span><span class="p">,</span> <span class="n">lin2z</span><span class="p">,</span> <span class="n">ts_to_dt</span><span class="p">,</span> <span class="n">dt_to_ts</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="replace_fill_value"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.replace_fill_value">[docs]</a><span class="k">def</span> <span class="nf">replace_fill_value</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">newfill</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replaces the fill value of an spectrum container by their time and range specific mean noise level.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (numpy.array) : 3D spectrum array (time, range, velocity)</span>
<span class="sd">        newfill (numpy.array) : 2D new fill values for 3rd dimension (velocity)</span>

<span class="sd">    Returns:</span>
<span class="sd">        var (numpy.array): spectrum with mean noise</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">masked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">iT</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ts</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rg</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">masked</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]:</span>
                <span class="n">var</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">newfill</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">var</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">newfill</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">var</span></div>


<span class="k">def</span> <span class="nf">get_chirp_from_range</span><span class="p">(</span><span class="n">rg_offsets</span><span class="p">,</span> <span class="n">i_rg</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ioff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rg_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="k">if</span> <span class="n">i_rg</span> <span class="o">&lt;=</span> <span class="n">ioff</span><span class="p">:</span> <span class="k">return</span> <span class="n">i</span>


<div class="viewcode-block" id="estimate_noise_hs74"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.estimate_noise_hs74">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">estimate_noise_hs74</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">navg</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">std_div</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span> <span class="n">nnoise_min</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;REFERENCE TO ARM PYART GITHUB REPO: https://github.com/ARM-DOE/pyart/blob/master/pyart/util/hildebrand_sekhon.py</span>

<span class="sd">    Estimate noise parameters of a Doppler spectrum.</span>
<span class="sd">    Use the method of estimating the noise level in Doppler spectra outlined</span>
<span class="sd">    by Hildebrand and Sehkon, 1974.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectrum (array): Doppler spectrum in linear units.</span>
<span class="sd">        navg (int, optional): The number of spectral bins over which a moving average </span>
<span class="sd">            has been taken. Corresponds to the **p** variable from equation 9 of the article. </span>
<span class="sd">            The default value of 1 is appropriate when no moving average has been applied to the spectrum.</span>
<span class="sd">        std_div (float, optional): Number of standard deviations above mean noise floor to specify the</span>
<span class="sd">            signal threshold, default: threshold=mean_noise + 6*std(mean_noise)</span>
<span class="sd">        nnoise_min (int, optional): Minimum number of noise samples to consider the estimation valid.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple with</span>

<span class="sd">        - **mean** (*float*): Mean of points in the spectrum identified as noise.</span>
<span class="sd">        - **threshold** (*float*): Threshold separating noise from signal. The point in the spectrum with</span>
<span class="sd">          this value or below should be considered as noise, above this value</span>
<span class="sd">          signal. It is possible that all points in the spectrum are identified</span>
<span class="sd">          as noise. If a peak is required for moment calculation then the point</span>
<span class="sd">          with this value should be considered as signal.</span>
<span class="sd">        - **var** (*float*): Variance of the points in the spectrum identified as noise.</span>
<span class="sd">        - **nnoise** (*int*): Number of noise points in the spectrum.</span>

<span class="sd">    References:</span>
<span class="sd">        P. H. Hildebrand and R. S. Sekhon, Objective Determination of the Noise</span>
<span class="sd">        Level in Doppler Spectra. Journal of Applied Meteorology, 1974, 13, 808-811.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sorted_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
    <span class="n">nnoise</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>  <span class="c1"># default to all points in the spectrum as noise</span>

    <span class="n">rtest</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">navg</span>
    <span class="n">sum1</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">sum2</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">pwr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_spectrum</span><span class="p">):</span>
        <span class="n">npts</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">npts</span> <span class="o">&lt;</span> <span class="n">nnoise_min</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">sum1</span> <span class="o">+=</span> <span class="n">pwr</span>
        <span class="n">sum2</span> <span class="o">+=</span> <span class="n">pwr</span> <span class="o">*</span> <span class="n">pwr</span>

        <span class="k">if</span> <span class="n">npts</span> <span class="o">*</span> <span class="n">sum2</span> <span class="o">&lt;</span> <span class="n">sum1</span> <span class="o">*</span> <span class="n">sum1</span> <span class="o">*</span> <span class="n">rtest</span><span class="p">:</span>
            <span class="n">nnoise</span> <span class="o">=</span> <span class="n">npts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># partial spectrum no longer has characteristics of white noise.</span>
            <span class="n">sum1</span> <span class="o">-=</span> <span class="n">pwr</span>
            <span class="n">sum2</span> <span class="o">-=</span> <span class="n">pwr</span> <span class="o">*</span> <span class="n">pwr</span>
            <span class="k">break</span>

    <span class="n">mean</span> <span class="o">=</span> <span class="n">sum1</span> <span class="o">/</span> <span class="n">nnoise</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">sum2</span> <span class="o">/</span> <span class="n">nnoise</span> <span class="o">-</span> <span class="n">mean</span> <span class="o">*</span> <span class="n">mean</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">mean</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="o">*</span> <span class="n">std_div</span>

    <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">nnoise</span></div>


<div class="viewcode-block" id="find_peak_edges"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.find_peak_edges">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">find_peak_edges</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">imaxima</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the indices of left and right edge of the main signal peak in a Doppler spectra.</span>

<span class="sd">    Args:</span>
<span class="sd">        signal (numpy.array): 1D array Doppler spectra</span>
<span class="sd">        threshold: noise threshold</span>

<span class="sd">    Returns:</span>
<span class="sd">        [index_left, index_right] (list): indices of signal minimum/maximum velocity</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">len_sig</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="n">index_left</span><span class="p">,</span> <span class="n">index_right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len_sig</span>
    <span class="k">if</span> <span class="n">threshold</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">imaxima</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span> <span class="n">imaxima</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ispec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imaxima</span><span class="p">,</span> <span class="n">len_sig</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">signal</span><span class="p">[</span><span class="n">ispec</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">index_right</span> <span class="o">=</span> <span class="n">ispec</span>
        <span class="k">break</span>

    <span class="k">for</span> <span class="n">ispec</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">imaxima</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">signal</span><span class="p">[</span><span class="n">ispec</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span> <span class="k">continue</span>
        <span class="n">index_left</span> <span class="o">=</span> <span class="n">ispec</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># the +1 is important, otherwise a fill_value will corrupt the numba code</span>
        <span class="k">break</span>

    <span class="k">return</span> <span class="n">threshold</span><span class="p">,</span> <span class="p">[</span><span class="n">index_left</span><span class="p">,</span> <span class="n">index_right</span><span class="p">]</span></div>


<div class="viewcode-block" id="radar_moment_calculation"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.radar_moment_calculation">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">radar_moment_calculation</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">vel_bins</span><span class="p">,</span> <span class="n">DoppRes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of radar moments: reflectivity, mean Doppler velocity, spectral width,</span>
<span class="sd">    skewness, and kurtosis of one Doppler spectrum. Optimized for the use of Numba.</span>

<span class="sd">    Note:</span>
<span class="sd">        Divide the signal_sum by 2 because vertical and horizontal channel are added.</span>
<span class="sd">        Subtract half of of the Doppler resolution from mean Doppler velocity, because</span>

<span class="sd">    Args:</span>
<span class="sd">        - signal (float array): detected signal from a Doppler spectrum</span>
<span class="sd">        - vel_bins (float array): extracted velocity bins of the signal (same length as signal)</span>
<span class="sd">        - DoppRes (int): resolution of the Doppler spectra (different for each chirp)</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict containing</span>

<span class="sd">        - **Ze_lin** (*float array*): reflectivity (0.Mom) over range of velocity bins [mm6/m3]</span>
<span class="sd">        - **VEL** (*float array*): mean velocity (1.Mom) over range of velocity bins [m/s]</span>
<span class="sd">        - **sw** (*float array*): spectrum width (2.Mom) over range of velocity bins [m/s]</span>
<span class="sd">        - **skew** (*float array*): skewness (3.Mom) over range of velocity bins</span>
<span class="sd">        - **kurt** (*float array*): kurtosis (4.Mom) over range of velocity bins</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">signal_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>  <span class="c1"># linear full spectrum Ze [mm^6/m^3], scalar</span>
    <span class="n">Ze_lin</span> <span class="o">=</span> <span class="n">signal_sum</span> <span class="o">/</span> <span class="mf">2.0</span>
    <span class="n">pwr_nrm</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">signal_sum</span>  <span class="c1"># determine normalized power (NOT normalized by Vdop bins)</span>

    <span class="n">VEL</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vel_bins</span> <span class="o">*</span> <span class="n">pwr_nrm</span><span class="p">)</span>
    <span class="n">vel_diff</span> <span class="o">=</span> <span class="n">vel_bins</span> <span class="o">-</span> <span class="n">VEL</span>
    <span class="n">vel_diff2</span> <span class="o">=</span> <span class="n">vel_diff</span> <span class="o">*</span> <span class="n">vel_diff</span>
    <span class="n">sw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pwr_nrm</span> <span class="o">*</span> <span class="n">vel_diff2</span><span class="p">)))</span>
    <span class="n">sw2</span> <span class="o">=</span> <span class="n">sw</span> <span class="o">*</span> <span class="n">sw</span>
    <span class="n">skew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pwr_nrm</span> <span class="o">*</span> <span class="n">vel_diff</span> <span class="o">*</span> <span class="n">vel_diff2</span> <span class="o">/</span> <span class="p">(</span><span class="n">sw</span> <span class="o">*</span> <span class="n">sw2</span><span class="p">))</span>
    <span class="n">kurt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">pwr_nrm</span> <span class="o">*</span> <span class="n">vel_diff2</span> <span class="o">*</span> <span class="n">vel_diff2</span> <span class="o">/</span> <span class="p">(</span><span class="n">sw2</span> <span class="o">*</span> <span class="n">sw2</span><span class="p">))</span>
    <span class="n">VEL</span> <span class="o">=</span> <span class="n">VEL</span> <span class="o">-</span> <span class="n">DoppRes</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="k">return</span> <span class="n">Ze_lin</span><span class="p">,</span> <span class="n">VEL</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">skew</span><span class="p">,</span> <span class="n">kurt</span></div>


<div class="viewcode-block" id="despeckle"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.despeckle">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">despeckle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">min_percentage</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove small patches (speckle) from any given mask by checking 5x5 box</span>
<span class="sd">    around each pixel, more than half of the points in the box need to be 1</span>
<span class="sd">    to keep the 1 at current pixel</span>

<span class="sd">    Args:</span>
<span class="sd">        mask (numpy.array, integer): 2D mask where 1 = an invalid/fill value and 0 = a data point (time, height)</span>
<span class="sd">        min_percentage (float): minimum percentage of neighbours that need to be signal above noise</span>

<span class="sd">    Returns:</span>
<span class="sd">        mask ... speckle-filtered matrix of 0 and 1 that represents (cloud) mask [height x time]</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">WSIZE</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># 5x5 window</span>
    <span class="n">n_bins</span> <span class="o">=</span> <span class="n">WSIZE</span> <span class="o">*</span> <span class="n">WSIZE</span>
    <span class="n">min_bins</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">min_percentage</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">n_bins</span><span class="p">)</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">WSIZE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">for</span> <span class="n">iT</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ts</span> <span class="o">-</span> <span class="n">WSIZE</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rg</span> <span class="o">-</span> <span class="n">WSIZE</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">iT</span><span class="p">:</span><span class="n">iT</span> <span class="o">+</span> <span class="n">WSIZE</span><span class="p">,</span> <span class="n">iR</span><span class="p">:</span><span class="n">iR</span> <span class="o">+</span> <span class="n">WSIZE</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">min_bins</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">iT</span> <span class="o">+</span> <span class="n">shift</span><span class="p">,</span> <span class="n">iR</span> <span class="o">+</span> <span class="n">shift</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="make_container_from_spectra"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.make_container_from_spectra">[docs]</a><span class="k">def</span> <span class="nf">make_container_from_spectra</span><span class="p">(</span><span class="n">spectra_all_chirps</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">paraminfo</span><span class="p">,</span> <span class="n">invalid_mask</span><span class="p">,</span> <span class="n">varname</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine will generate a larda container from calculated moments from spectra.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectra_all_chirps (list of dicts): dimension [nchirps], containing the spectrum</span>
<span class="sd">                                            values of the 94 GHz RPG cloud radar</span>
<span class="sd">        values (numpy array): dimension [nrange, ntimes], values of calculated moments</span>
<span class="sd">        paraminfo (dict): information from params_[campaign].toml for the specific variable</span>

<span class="sd">    Returns:</span>
<span class="sd">        container (dict): larda data container</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">varname</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spectra_all_chirps</span> <span class="o">=</span> <span class="p">[</span><span class="n">spectra_all_chirps</span><span class="p">[</span><span class="n">ic</span><span class="p">][</span><span class="n">varname</span><span class="p">]</span> <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">spectra_all_chirps</span><span class="p">))]</span>

    <span class="n">spectra</span> <span class="o">=</span> <span class="n">spectra_all_chirps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">#np.array([rg for ic in spectra_all_chirps for rg in ic[&#39;rg&#39;]])</span>
    <span class="n">container</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;dimlabel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;range&#39;</span><span class="p">],</span>
                 <span class="s1">&#39;filename&#39;</span><span class="p">:</span> <span class="n">spectra</span><span class="p">[</span><span class="s1">&#39;filename&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;filename&#39;</span> <span class="ow">in</span> <span class="n">spectra</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;paraminfo&#39;</span><span class="p">:</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">paraminfo</span><span class="p">),</span>
                 <span class="s1">&#39;rg_unit&#39;</span><span class="p">:</span> <span class="n">paraminfo</span><span class="p">[</span><span class="s1">&#39;rg_unit&#39;</span><span class="p">],</span> <span class="s1">&#39;colormap&#39;</span><span class="p">:</span> <span class="n">paraminfo</span><span class="p">[</span><span class="s1">&#39;colormap&#39;</span><span class="p">],</span>
                 <span class="s1">&#39;var_unit&#39;</span><span class="p">:</span> <span class="n">paraminfo</span><span class="p">[</span><span class="s1">&#39;var_unit&#39;</span><span class="p">],</span>
                 <span class="s1">&#39;var_lims&#39;</span><span class="p">:</span> <span class="n">paraminfo</span><span class="p">[</span><span class="s1">&#39;var_lims&#39;</span><span class="p">],</span>
                 <span class="s1">&#39;system&#39;</span><span class="p">:</span> <span class="n">paraminfo</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">],</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">paraminfo</span><span class="p">[</span><span class="s1">&#39;paramkey&#39;</span><span class="p">],</span>
                 <span class="s1">&#39;rg&#39;</span><span class="p">:</span> <span class="n">spectra</span><span class="p">[</span><span class="s1">&#39;rg&#39;</span><span class="p">],</span> <span class="s1">&#39;ts&#39;</span><span class="p">:</span> <span class="n">spectra</span><span class="p">[</span><span class="s1">&#39;ts&#39;</span><span class="p">],</span>
                 <span class="s1">&#39;mask&#39;</span><span class="p">:</span> <span class="n">invalid_mask</span><span class="p">,</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="n">values</span><span class="p">[:]}</span>

    <span class="k">return</span> <span class="n">container</span></div>


<div class="viewcode-block" id="load_spectra_rpgfmcw94"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.load_spectra_rpgfmcw94">[docs]</a><span class="k">def</span> <span class="nf">load_spectra_rpgfmcw94</span><span class="p">(</span><span class="n">larda</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="n">rpg_radar</span><span class="o">=</span><span class="s1">&#39;LIMRAD94&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine will generate a list of larda containers including spectra of the RPG-FMCW 94GHz radar.</span>
<span class="sd">    The list-container at return will contain the additional information, for each chirp.</span>

<span class="sd">    Args:</span>
<span class="sd">        rpg_radar (string): name of the radar system as defined in the toml file</span>
<span class="sd">        larda (class larda): Initialized pyLARDA, already connected to a specific campaign</span>
<span class="sd">        time_span (list): Starting and ending time point in datetime format.</span>
<span class="sd">        **noise_factor (float): Noise factor, number of standard deviations from mean noise floor</span>
<span class="sd">        **ghost_echo_1 (bool): Filters ghost echos which occur over all chirps during precipitation.</span>
<span class="sd">        **ghost_echo_2 (bool): Filters ghost echos which occur over 1 chirps during precipitation.</span>
<span class="sd">        **estimate_noise (boal): If True, adds the following noise estimation values to the container:</span>

<span class="sd">            -   mean (2d ndarray): Mean noise level of the spectra.</span>
<span class="sd">            -   threshold (2d ndarray): Noise threshold, values above this threshold are consider as signal.</span>
<span class="sd">            -   variance (2d ndarray): The variance of the mean noise level.</span>
<span class="sd">            -   numnoise (2d ndarray): Number of Pixels that are cconsideras noise.</span>
<span class="sd">            -   signal (2d ndarray): Boolean array, a value is True if no signal was detected.</span>
<span class="sd">            -   bounds (3d ndarrax): Dimensions [n_time, n_range, 2] containing the integration boundaries.</span>

<span class="sd">    Returns:</span>
<span class="sd">        container (list): list of larda data container</span>

<span class="sd">        - **spec[i_chirps][&#39;no_av&#39;]** (*float*): Number of spectral averages divided by the number of FFT points</span>
<span class="sd">        - **spec[i_chirps][&#39;DoppRes&#39;]** (*float*): Doppler resolution for</span>
<span class="sd">        - **spec[i_chirps][&#39;SL&#39;]** (*2D-float*): Sensitivity limit (dimensions: time, range)</span>
<span class="sd">        - **spec[i_chirps][&#39;NF&#39;]** (*string*): Noise factor, default = 6.0</span>
<span class="sd">        - **spec[i_chirps][&#39;rg_offsets&#39;]** (*list*): Indices, where chipr shifts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># read limrad94 doppler spectra and caluclate radar moments</span>
    <span class="n">std_above_mean_noise</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;noise_factor&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;noise_factor&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="mf">6.0</span>
    <span class="n">heave_correct</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;heave_correction&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;heave_correction&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">version</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;heave_corr_version&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;heave_corr_version&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="s1">&#39;jr&#39;</span>
    <span class="n">add</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;add&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;add&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;shift&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">dealiasing_flag</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dealiasing&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;dealiasing&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">ghost_echo_1</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ghost_echo_1&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;ghost_echo_1&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">ghost_echo_2</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ghost_echo_2&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;ghost_echo_2&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">do_despeckle2D</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;despeckle2D&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;despeckle2D&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">True</span>
    <span class="n">add_horizontal_channel</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="s1">&#39;add_horizontal_channel&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;add_horizontal_channel&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">False</span>
    <span class="n">estimate_noise</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">std_above_mean_noise</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="n">AvgNum_in</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s2">&quot;AvgNum&quot;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">)</span>
    <span class="n">DoppLen_in</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s2">&quot;DoppLen&quot;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">)</span>
    <span class="n">MaxVel_in</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s2">&quot;MaxVel&quot;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">)</span>
    <span class="n">ChirpFFTSize_in</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s2">&quot;ChirpFFTSize&quot;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">)</span>
    <span class="n">SeqIntTime_in</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s2">&quot;SeqIntTime&quot;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># depending on how much files are loaded, AvgNum and DoppLen are multidimensional list</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">AvgNum_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">AvgNum</span> <span class="o">=</span> <span class="n">AvgNum_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">DoppLen</span> <span class="o">=</span> <span class="n">DoppLen_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ChirpFFTSize</span> <span class="o">=</span> <span class="n">ChirpFFTSize_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">DoppRes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">MaxVel_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">DoppLen_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">MaxVel</span> <span class="o">=</span> <span class="n">MaxVel_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">SeqIntTime</span> <span class="o">=</span> <span class="n">SeqIntTime_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">AvgNum</span> <span class="o">=</span> <span class="n">AvgNum_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
        <span class="n">DoppLen</span> <span class="o">=</span> <span class="n">DoppLen_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
        <span class="n">ChirpFFTSize</span> <span class="o">=</span> <span class="n">ChirpFFTSize_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
        <span class="n">DoppRes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">MaxVel_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">DoppLen_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">])</span>
        <span class="n">MaxVel</span> <span class="o">=</span> <span class="n">MaxVel_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
        <span class="n">SeqIntTime</span> <span class="o">=</span> <span class="n">SeqIntTime_in</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>

    <span class="c1"># initialize</span>
    <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">add_horizontal_channel</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SLh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s2">&quot;SLh&quot;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;HSpec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s1">&#39;HSpec&#39;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ReVHSpec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s1">&#39;ImVHSpec&#39;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ImVHSpec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s1">&#39;ReVHSpec&#39;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>

    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s1">&#39;VSpec&#39;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SLv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s2">&quot;SLv&quot;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mdv&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s1">&#39;VEL&#39;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;NF&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">std_above_mean_noise</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;no_av&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">AvgNum</span><span class="p">,</span> <span class="n">DoppLen</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;DoppRes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DoppRes</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;DoppLen&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DoppLen</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;MaxVel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">MaxVel</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ChirpFFTSize&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ChirpFFTSize</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SeqIntTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SeqIntTime</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_ts&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_rg&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_vel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_ch&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">MaxVel</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;C1Range&#39;</span><span class="p">,</span> <span class="s1">&#39;C2Range&#39;</span><span class="p">,</span> <span class="s1">&#39;C3Range&#39;</span><span class="p">]:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;loading variable from LV1 :: &#39;</span> <span class="o">+</span> <span class="n">var</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">var</span><span class="p">:</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])})</span>

    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">AvgNum</span><span class="p">)):</span>
        <span class="n">nrange_</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;C</span><span class="si">{</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">Range&#39;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">)[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nrange_</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">nrange_</span> <span class="o">=</span> <span class="n">nrange_</span><span class="o">.</span><span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nrange_</span> <span class="o">=</span> <span class="n">nrange_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">][</span><span class="n">ic</span><span class="p">]</span> <span class="o">+</span> <span class="n">nrange_</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">MaxVel</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">DoppRes</span><span class="p">[</span><span class="n">ic</span><span class="p">]),</span> <span class="o">+</span><span class="n">MaxVel</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">DoppRes</span><span class="p">[</span><span class="n">ic</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">DoppLen</span><span class="p">)))</span>

    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading spectra, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ####################################################################################################################</span>
<span class="sd">    ____ ___  ___  _ ___ _ ____ _  _ ____ _       ___  ____ ____ ___  ____ ____ ____ ____ ____ ____ _ _  _ ____ </span>
<span class="sd">    |__| |  \ |  \ |  |  | |  | |\ | |__| |       |__] |__/ |___ |__] |__/ |  | |    |___ [__  [__  | |\ | | __ </span>
<span class="sd">    |  | |__/ |__/ |  |  | |__| | \| |  | |___    |    |  \ |___ |    |  \ |__| |___ |___ ___] ___] | | \| |__]</span>

<span class="sd">    ####################################################################################################################                                                                                                             </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">heave_correct</span><span class="p">:</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">current_day</span> <span class="o">=</span> <span class="n">ts_to_dt</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;ts&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;heave_cor&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;heave_cor_bins&#39;</span><span class="p">],</span> <span class="n">_</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time_shift_array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">heave_correction_spectra</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">current_day</span><span class="p">,</span>
            <span class="n">path_to_seapath</span><span class="o">=</span><span class="s2">&quot;/projekt2/remsens/data_new/site-campaign/rv_meteor-eurec4a/instruments/RV-METEOR_DSHIP&quot;</span><span class="p">,</span>
            <span class="n">mean_hr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">only_heave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">use_cross_product</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">transform_to_earth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">add</span><span class="o">=</span><span class="n">add</span><span class="p">,</span>
            <span class="n">shift</span><span class="o">=</span><span class="n">shift</span><span class="p">,</span>
            <span class="n">version</span><span class="o">=</span><span class="n">version</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Heave correction applied, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">do_despeckle2D</span><span class="p">:</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;dspkl_mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">despeckle2D</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;dspkl_mask&#39;</span><span class="p">]],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;mask&#39;</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;dspkl_mask&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">,</span> <span class="kc">True</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Despeckle applied, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>

    <span class="c1"># read spectra and other variables</span>
    <span class="k">if</span> <span class="n">estimate_noise</span><span class="p">:</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_ts&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_rg&#39;</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Vnoise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s1">&#39;VNoisePow&#39;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">add_horizontal_channel</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Hnoise&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">larda</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">rpg_radar</span><span class="p">,</span> <span class="s1">&#39;HNoisePow&#39;</span><span class="p">,</span> <span class="n">time_span</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>

            <span class="c1"># initialize arrays</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_ts&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_rg&#39;</span><span class="p">]),</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_ts&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_rg&#39;</span><span class="p">]),</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">)</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">tmp</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="c1"># catch RuntimeWarning: All-NaN slice encountered</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;thresh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;var_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># find all-noise-spectra (aka. fill_value)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;thresh&#39;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Vnoise&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">tmp</span>

        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;KeyError: Noise Power variable not found, calculate noise level...&#39;</span><span class="p">)</span>
            <span class="n">noise_est</span> <span class="o">=</span> <span class="n">noise_estimation_uncompressed_data</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">],</span> <span class="n">no_av</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;no_av&#39;</span><span class="p">],</span> <span class="n">n_std</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span> <span class="n">rg_offsets</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">])</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">noise_est</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;thresh&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">noise_est</span><span class="p">[</span><span class="s1">&#39;threshold&#39;</span><span class="p">]</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.0</span>

            <span class="c1"># IGNORES: RuntimeWarning: invalid value encountered in less:</span>
            <span class="c1">#                          masking = data[&#39;VHSpec&#39;][&#39;var&#39;][iT, iR, :] &lt; data[&#39;thresh&#39;][iT, iR]</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">iT</span><span class="p">,</span> <span class="n">iR</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_ts&#39;</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_rg&#39;</span><span class="p">])):</span>
                    <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]:</span> <span class="k">continue</span>
                    <span class="n">masking</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;thresh&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">masking</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.0</span>

        <span class="k">if</span> <span class="n">dealiasing_flag</span><span class="p">:</span>
            <span class="n">dealiased_spec</span><span class="p">,</span> <span class="n">dealiased_mask</span><span class="p">,</span> <span class="n">new_vel</span><span class="p">,</span> <span class="n">new_bounds</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">dealiasing</span><span class="p">(</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">],</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vel&#39;</span><span class="p">],</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SLv&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">],</span>
                <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">],</span>
                <span class="n">vel_offsets</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;dealiasing_vel&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;dealiasing_vel&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">show_triple</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>

            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dealiased_spec</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dealiased_mask</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;vel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vel</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># copy to larda container</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_vel</span>  <span class="c1"># copy all veloctiys</span>
            <span class="n">data</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_bounds</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iT</span><span class="p">,</span> <span class="n">iR</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_ts&#39;</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_rg&#39;</span><span class="p">])):</span>
                <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]:</span> <span class="k">continue</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">find_peak_edges</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;thresh&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">])</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loading Noise Level, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ghost_echo_1</span><span class="p">:</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ge1_mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_ghost_1</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;rg&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;vel&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Precipitation Ghost Filter applied, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of ghost pixel due to precipitation = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ge1_mask&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ge1_mask&#39;</span><span class="p">]],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;mask&#39;</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ge1_mask&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">,</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">ghost_echo_2</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;ge2_mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">filter_ghost_2</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;rg&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SLv&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Curtain-like Ghost Filter applied, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of curtain-like ghost pixel = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;ge2_mask&quot;</span><span class="p">])</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ge2_mask&#39;</span><span class="p">]],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;mask&#39;</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;ge2_mask&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">,</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">do_despeckle2D</span><span class="p">:</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;dspkl_mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">despeckle2D</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">])</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;dspkl_mask&#39;</span><span class="p">]],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;mask&#39;</span><span class="p">][</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;dspkl_mask&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">,</span> <span class="kc">True</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Despeckle applied, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="dealiasing_check"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.dealiasing_check">[docs]</a><span class="k">def</span> <span class="nf">dealiasing_check</span><span class="p">(</span><span class="n">masked3D</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Checks for folding.</span>

<span class="sd">    Args:</span>
<span class="sd">        masked3D (numpy.array): 3D (time, range, velocity)</span>
<span class="sd">        vel (list): contains 1D numpy.arrays for each chirp</span>
<span class="sd">        mean_noise (numpy.array):</span>
<span class="sd">        rg_offsets (numpy.array):</span>

<span class="sd">    Returns:</span>
<span class="sd">        alias_flag (numpy.array):</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">frac</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">alias_flag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">masked3D</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">masked2D</span> <span class="o">=</span> <span class="n">masked3D</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Nfft</span> <span class="o">=</span> <span class="n">masked3D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">frac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nfft</span> <span class="o">/</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">iT</span><span class="p">,</span> <span class="n">iR</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">masked3D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">masked3D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>

        <span class="k">if</span> <span class="n">masked2D</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]:</span> <span class="k">continue</span>  <span class="c1"># no signal was recorded</span>

        <span class="c1"># check if aliasing occured by checking if more than &#39;frac&#39; percent of the bins exceeded</span>
        <span class="c1"># mean noise level at one of the spectra</span>
        <span class="n">n_start</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">masked3D</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:</span><span class="n">frac</span><span class="p">])</span>
        <span class="n">n_end</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">masked3D</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">Nfft</span><span class="o">-</span><span class="n">frac</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">Nfft</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">n_start</span> <span class="o">&gt;=</span> <span class="n">frac</span> <span class="ow">or</span> <span class="n">n_end</span> <span class="o">&gt;=</span> <span class="n">frac</span><span class="p">:</span> <span class="n">alias_flag</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># then aliasing detected</span>


    <span class="k">return</span> <span class="n">alias_flag</span></div>


<div class="viewcode-block" id="dealiasing"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.dealiasing">[docs]</a><span class="k">def</span> <span class="nf">dealiasing</span><span class="p">(</span>
        <span class="n">spectra</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">vel_bins_per_chirp</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span>
        <span class="n">noisefloor</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
        <span class="n">rg_offsets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">show_triple</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">vel_offsets</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">jump</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Peaks exceeding the maximum unambiguous Doppler velocity range of  v_Nyq in [m s-1]</span>
<span class="sd">        appear at the next upper (lower) range gate at the other end of the velocity spectrum.</span>
<span class="sd">        The dealiasing method presented here aims to correct for this and is applied to every time step.</span>

<span class="sd">        Logging level INFO shows the de-aliasing progress bar.</span>

<span class="sd">    Args:</span>
<span class="sd">        spectra: dim = (n_time, n_range, n_velocity) in linear units!</span>
<span class="sd">        vel_bins_per_chirp: len = (n_chirp), each list element contains a numpy array of velocity bins</span>
<span class="sd">        noisefloor: dim = (n_time, n_range) in linear units!</span>
<span class="sd">        rg_offsets (optional): dim = (n_chirp + 1), starting with 0, range indices where chirp shift occurs</span>
<span class="sd">        show_triple (optional): if True, return dealiased spectra including the triplication</span>
<span class="sd">        vel_offsets (optional): velocity window around the main peak [x1, x2], x1 &lt; 0, x2 &gt; 0 ! in [m s-1], default [-6.0, +9.0]</span>
<span class="sd">        jump (optional): maximum number of Doppler bins a spectrum can change in two adjacent range bins</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple containing</span>

<span class="sd">        - **dealiased_spectra**: dim = (n_time, n_range, 3 * n_velocity), de-aliased Doppler spectrum</span>
<span class="sd">        - **dealiased_mask**: dim = (n_time, n_range, 3 * n_velocity), True if no signal</span>
<span class="sd">        - **velocity_new**: len = (n_chirp), each list element contains a numpy array of velocity bins for the respective chirp of  3*v_Nyq in [m s-1]</span>
<span class="sd">        - **signal_boundaries**: indices of left and right edge of a signal, [-1, -1] if no signal</span>
<span class="sd">        - **search_path**: indices of left and right edge of the search path, [-1, -1] if no signal</span>
<span class="sd">        - **idx_peak_matrix**: indices of the main peaks, [NDbins / 2] if no signal</span>

<span class="sd">    .. todo::</span>

<span class="sd">        - add time--height mask for dealiasing</span>
<span class="sd">        - search window relative to [m s-1]</span>
<span class="sd">        - abs(idx_new_peak - mean_idx_last_ts) &gt; 120: --&gt; relativ</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">,</span> <span class="n">n_vel</span><span class="p">),</span> <span class="n">n_ch</span> <span class="o">=</span> <span class="n">spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rg_offsets</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">n_vel_new</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">n_vel</span>

    <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">jump</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">jump</span> <span class="o">=</span> <span class="n">n_vel</span> <span class="o">//</span> <span class="mi">2</span>

    <span class="c1"># triplicate velocity bins</span>
    <span class="n">velocity_new</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vel_bins_per_chirp</span><span class="p">:</span>
        <span class="n">vel_range</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">velocity_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">vel_range</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">vel_range</span><span class="p">,</span> <span class="n">n_vel_new</span><span class="p">))</span>

    <span class="c1"># set (n_rg, 2) array containing velocity index offset velocty_jump_tolerance from maxima from last range gate</span>
    <span class="n">_one_in_all</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">7.0</span><span class="p">,</span> <span class="o">+</span><span class="mf">7.0</span><span class="p">]</span> <span class="k">if</span> <span class="n">vel_offsets</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">vel_offsets</span>

    <span class="n">velocty_jump_tolerance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_one_in_all</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch</span><span class="p">)])</span>  <span class="c1">#  [m s-1]</span>

    <span class="n">rg_diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rg_offsets</span><span class="p">)</span>
    <span class="n">Dopp_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">vel_bins_per_chirp</span><span class="p">[</span><span class="n">ic</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">vel_bins_per_chirp</span><span class="p">[</span><span class="n">ic</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch</span><span class="p">)])</span>

    <span class="n">iDbinTol</span> <span class="o">=</span> <span class="p">[</span><span class="n">velocty_jump_tolerance</span><span class="p">[</span><span class="n">ires</span><span class="p">,</span> <span class="p">:]</span> <span class="o">//</span> <span class="n">res</span> <span class="k">for</span> <span class="n">ires</span><span class="p">,</span> <span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Dopp_res</span><span class="p">)]</span>
    <span class="n">iDbinTol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">iDbinTol</span><span class="p">[</span><span class="n">ic</span><span class="p">]]</span> <span class="o">*</span> <span class="n">rg_diffs</span><span class="p">[</span><span class="n">ic</span><span class="p">])</span> <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ch</span><span class="p">)])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>

    <span class="c1"># triplicate spectra</span>
    <span class="n">Z_linear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">spectra</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># initialize arrays for dealiasing</span>
    <span class="n">window_fcn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">(</span><span class="n">n_vel_new</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">)</span>
    <span class="n">signal_boundaries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">search_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">dealiased_spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">Z_linear</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">dealiased_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">Z_linear</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">idx_peak_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">n_vel_new</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
    <span class="n">all_clear</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">spectra</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">noisefloor</span><span class="p">)</span>
    <span class="n">noise_mask</span> <span class="o">=</span> <span class="n">spectra</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">noise</span>
    <span class="n">noise</span><span class="p">[</span><span class="n">noise_mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">spectra</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)[</span><span class="n">noise_mask</span><span class="p">]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Doppler resolution per chirp : </span><span class="si">{</span><span class="n">Dopp_res</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Doppler spectra de-aliasing....... &#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iT</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ts</span><span class="p">)</span> <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="k">else</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_ts</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; timesteps&#39;</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="n">n_ts</span><span class="p">):</span>

        <span class="c1"># entire profile is clear sky</span>
        <span class="k">if</span> <span class="n">all_clear</span><span class="p">[</span><span class="n">iT</span><span class="p">]:</span>  <span class="k">continue</span>

        <span class="c1"># assume no dealiasing at upper most range gate</span>
        <span class="n">idx_last_peak</span> <span class="o">=</span> <span class="n">n_vel_new</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="c1"># Top-Down approach: check range gates below</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rg</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>

            <span class="c1"># the search window for the next peak maximum surrounds  velocity_jump_tolerance [m s-1] around the last peak maximum</span>
            <span class="n">search_window</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">idx_last_peak</span> <span class="o">+</span> <span class="n">iDbinTol</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">idx_last_peak</span> <span class="o">+</span> <span class="n">iDbinTol</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">n_vel_new</span><span class="p">))</span>
            <span class="n">Z_windowed</span> <span class="o">=</span> <span class="n">Z_linear</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">window_fcn</span><span class="p">,</span> <span class="n">n_vel_new</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">idx_last_peak</span><span class="p">)</span>
            <span class="n">Z_windowed</span> <span class="o">=</span> <span class="n">Z_windowed</span><span class="p">[</span><span class="n">search_window</span><span class="p">]</span>  <span class="c1"># Note: Think about index shift!</span>
            <span class="n">idx_new_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Z_windowed</span><span class="p">)</span> <span class="o">+</span> <span class="n">search_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># check if Doppler velocity jumps more than 120 bins from last _eak max to new(=one rg below) peak max</span>
            <span class="n">mean_idx_last_ts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">idx_peak_matrix</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iT</span> <span class="o">-</span> <span class="n">k</span><span class="p">):</span><span class="nb">min</span><span class="p">(</span><span class="n">iT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_ts</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">iR</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span><span class="nb">min</span><span class="p">(</span><span class="n">iR</span> <span class="o">+</span> <span class="n">k</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">)]))</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">idx_new_peak</span> <span class="o">-</span> <span class="n">mean_idx_last_ts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">jump</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;jump at iT=</span><span class="si">{</span><span class="n">iT</span><span class="si">}</span><span class="s1">   iR=</span><span class="si">{</span><span class="n">iR</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">idx_new_peak</span> <span class="o">=</span> <span class="n">mean_idx_last_ts</span>
                <span class="n">search_window</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">idx_new_peak</span> <span class="o">+</span> <span class="n">iDbinTol</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">idx_new_peak</span> <span class="o">+</span> <span class="n">iDbinTol</span><span class="p">[</span><span class="n">iR</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">n_vel_new</span><span class="p">))</span>

            <span class="n">search_path</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">search_window</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">search_window</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>  <span class="c1"># for plotting</span>

            <span class="k">if</span> <span class="n">search_window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">idx_new_peak</span> <span class="o">&lt;</span> <span class="n">search_window</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="c1"># calc signal boundaries</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_bnd</span> <span class="o">=</span> <span class="n">find_peak_edges</span><span class="p">(</span><span class="n">Z_linear</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:],</span> <span class="n">threshold</span><span class="o">=</span><span class="n">noise</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">],</span> <span class="n">imaxima</span><span class="o">=</span><span class="n">idx_new_peak</span><span class="p">)</span>

                <span class="c1"># safety precautions, if idx-left-bound &gt; idx-right-bound --&gt; no signal</span>
                <span class="k">if</span> <span class="n">_bnd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">_bnd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># probably clear sky</span>
                    <span class="n">idx_peak_matrix</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_last_peak</span>
                    <span class="n">signal_boundaries</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal_boundaries</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">_bnd</span>
                    <span class="n">idx_peak_matrix</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_new_peak</span>
                    <span class="n">idx_last_peak</span> <span class="o">=</span> <span class="n">idx_new_peak</span>
                    <span class="c1"># if show_triple == True, copy all signals including the triplication else copy only the main signal and not the triplication</span>
                    <span class="n">_bnd_tmp</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="k">if</span> <span class="n">show_triple</span> <span class="k">else</span> <span class="n">_bnd</span>
                    <span class="n">dealiased_spectra</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">_bnd_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">_bnd_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Z_linear</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">_bnd_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">_bnd_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">dealiased_mask</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">_bnd_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">_bnd_tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># last peak stays the same, no integration boundaries</span>
                <span class="n">signal_boundaries</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">idx_peak_matrix</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_last_peak</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;signal boundaries(iR == </span><span class="si">{</span><span class="n">iR</span><span class="si">}</span><span class="s1">) = </span><span class="si">{</span><span class="n">signal_boundaries</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span><span class="si">}</span><span class="s1">     &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;idx_peak_max  </span><span class="si">{</span><span class="n">idx_peak_matrix</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span><span class="si">}</span><span class="s1">,     &#39;</span>
                         <span class="sa">f</span><span class="s1">&#39;min val = noise floor : </span><span class="si">{</span><span class="n">Z_linear</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="si">:</span><span class="s1">.7f</span><span class="si">}</span><span class="s1">, </span><span class="si">{</span><span class="n">noise</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span><span class="si">:</span><span class="s1">.7f</span><span class="si">}</span><span class="s1">     &#39;</span><span class="p">)</span>

    <span class="c1"># clean up signal boundaries</span>
    <span class="n">signal_boundaries</span><span class="p">[(</span><span class="n">signal_boundaries</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">signal_boundaries</span> <span class="o">&gt;=</span> <span class="n">n_vel_new</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">dealiased_spectra</span><span class="p">,</span> <span class="n">dealiased_mask</span><span class="p">,</span> <span class="n">velocity_new</span><span class="p">,</span> <span class="n">signal_boundaries</span><span class="p">,</span> <span class="n">search_path</span><span class="p">,</span> <span class="n">idx_peak_matrix</span></div>


<div class="viewcode-block" id="noise_estimation_uncompressed_data"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.noise_estimation_uncompressed_data">[docs]</a><span class="k">def</span> <span class="nf">noise_estimation_uncompressed_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n_std</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a dict containing the noise threshold, mean noise level,</span>
<span class="sd">    the variance of the noise, the number of noise values in the spectrum,</span>
<span class="sd">    and the boundaries of the main signal peak, if there is one</span>

<span class="sd">    Args:</span>
<span class="sd">        data (dict): data container, containing data[&#39;var&#39;] of dimension (n_ts, n_range, n_Doppler_bins)</span>
<span class="sd">        **n_std_deviations (float): threshold = number of standard deviations</span>
<span class="sd">                                    above mean noise floor, default: threshold is the value of the first</span>
<span class="sd">                                    non-noise value</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict with noise floor estimation for all time and range points</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">spectra3D</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">,</span> <span class="n">n_vel</span> <span class="o">=</span> <span class="n">spectra3D</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="s1">&#39;rg_offsets&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="n">rg_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">])</span>
        <span class="n">rg_offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">rg_offsets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rg_offsets</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_rg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">no_av</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;no_av&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;no_av&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># fill values needs to be masked for noise removal otherwise wrong results</span>
    <span class="n">spectra3D</span><span class="p">[</span><span class="n">spectra3D</span> <span class="o">==</span> <span class="o">-</span><span class="mf">999.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># Estimate Noise Floor for all chirps, time stemps and range gates aka. for all pixels</span>
    <span class="c1"># Algorithm used: Hildebrand &amp; Sekhon</span>

    <span class="c1"># allocate numpy arrays</span>
    <span class="n">noise_est</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="s1">&#39;variance&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="s1">&#39;numnoise&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
        <span class="s1">&#39;signal&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="c1"># gather noise level etc. for all chirps, range gates and times</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Noise estimation for uncompressed spectra....... &#39;</span><span class="p">)</span>
    <span class="n">noise_free</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spectra3D</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">iterator</span> <span class="o">=</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_ts</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rg</span><span class="p">))</span> <span class="k">if</span> <span class="n">logger</span><span class="o">.</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">20</span> <span class="k">else</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_ts</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rg</span><span class="p">)),</span> <span class="n">total</span><span class="o">=</span><span class="n">n_ts</span> <span class="o">*</span> <span class="n">n_rg</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39; spectra&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iT</span><span class="p">,</span> <span class="n">iR</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">noise_free</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">mean</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">nnoise</span> <span class="o">=</span> <span class="n">estimate_noise_hs74</span><span class="p">(</span>
            <span class="n">spectra3D</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">navg</span><span class="o">=</span><span class="n">no_av</span><span class="p">[</span><span class="n">getnointerval</span><span class="p">(</span><span class="n">rg_offsets</span><span class="p">,</span> <span class="n">iR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">std_div</span><span class="o">=</span><span class="n">n_std</span>
        <span class="p">)</span>

        <span class="n">noise_est</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="n">noise_est</span><span class="p">[</span><span class="s1">&#39;variance&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="n">var</span>
        <span class="n">noise_est</span><span class="p">[</span><span class="s1">&#39;numnoise&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="n">nnoise</span>
        <span class="n">noise_est</span><span class="p">[</span><span class="s1">&#39;threshold&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="n">thresh</span>
        <span class="n">noise_est</span><span class="p">[</span><span class="s1">&#39;signal&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> <span class="n">nnoise</span> <span class="o">&lt;</span> <span class="n">n_vel</span>

    <span class="k">return</span> <span class="n">noise_est</span></div>


<div class="viewcode-block" id="mira_noise_calculation"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.mira_noise_calculation">[docs]</a><span class="k">def</span> <span class="nf">mira_noise_calculation</span><span class="p">(</span><span class="n">radar_const</span><span class="p">,</span> <span class="n">SNRCorFaCo</span><span class="p">,</span> <span class="n">HSDco</span><span class="p">,</span> <span class="n">noise_power_co</span><span class="p">,</span> <span class="n">range_ka</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        radar_const:</span>
<span class="sd">        SNRCorFaCo:</span>
<span class="sd">        HSDco:</span>
<span class="sd">        noise_power_co:</span>
<span class="sd">        range_ka:</span>

<span class="sd">    Returns:</span>
<span class="sd">        noise level in linear units</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">noise_ka_lin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">HSDco</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iT</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radar_const</span><span class="p">)):</span>
        <span class="n">noise_ka_lin</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">radar_const</span><span class="p">[</span><span class="n">iT</span><span class="p">]</span> <span class="o">*</span> <span class="n">SNRCorFaCo</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">HSDco</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">noise_power_co</span><span class="p">[</span><span class="n">iT</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">range_ka</span> <span class="o">/</span> <span class="mf">5000.</span><span class="p">)</span> <span class="o">^</span> <span class="mf">2.</span>
    <span class="k">return</span> <span class="n">noise_ka_lin</span></div>


<span class="k">def</span> <span class="nf">getnointerval</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bisect</span><span class="o">.</span><span class="n">bisect_left</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">seconds_to_fstring</span><span class="p">(</span><span class="n">time_diff</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">fromtimestamp</span><span class="p">(</span><span class="n">time_diff</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s2">&quot;%M:%S&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="despeckle2D"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.despeckle2D">[docs]</a><span class="k">def</span> <span class="nf">despeckle2D</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">min_perc</span><span class="o">=</span><span class="mf">80.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function is used to remove all spectral lines for one time-range-pixel if surrounding% of the sourounding pixels are fill_values.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (numpy.array): cloud radar Doppler spectra, dimensions: (time, range, velocity), unit: [mm6 mm-3 m s-1]</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        min_perc (float): minimum percentage value of neighbouring pixel, that need to be above the noise threshold</span>

<span class="sd">    Returns:</span>
<span class="sd">        mask (numpy.array, bool): where True = fill_value, and False = signal, dimensions: (time, range, velocity)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># there must be high levels of reflection/scattering in this region to produce ghost echos</span>
    <span class="n">mask_2D</span> <span class="o">=</span> <span class="n">despeckle</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">data</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">min_perc</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">iBin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
        <span class="n">mask</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">iBin</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask_2D</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="filter_ghost_1"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.filter_ghost_1">[docs]</a><span class="k">def</span> <span class="nf">filter_ghost_1</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">dBZ_thresh</span><span class="o">=-</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">reduce_by</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function is used to remove certain spectral lines &quot;speckle ghost echoes&quot; from all chirps of RPG FMCW 94GHz cloud radar spectra.</span>
<span class="sd">    The speckle occur usually near the maximum unambiguous Doppler velocity.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (numpy.array): cloud radar Doppler spectra, dimensions: (time, range, velocity), unit: [mm6 mm-3 m s-1]</span>
<span class="sd">        rg (numpy.array): range values, unit [m]</span>
<span class="sd">        vel (list of numpy.arrays): contains the Doppler velocity values for each chirp, dimension = n_chirps</span>
<span class="sd">        offset (list, integer): range indices where the chirp changes takes place, dimension = n_chirps + 1 (starting with 0)</span>
<span class="sd">        dBZ_thresh (float): values below will be considered as ghost echo</span>
<span class="sd">        reduce_by (float): reduce the maximum unambiguous Doppler velocity by this amount in [m s-1]</span>
<span class="sd">        **ignore_chirp1 (bool): Don&#39;t filter ghost echos of this type for first chirp (set to True if not given)</span>
<span class="sd">        **Z_thresh (float): Ze in dBZ to be exceeded in lowest 500 m range for filter to be activated</span>

<span class="sd">    Returns:</span>
<span class="sd">        mask (numpy.array, bool): where True = fill_value, and False = signal, dimensions: (time, range, velocity)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ignore_chirp1</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;ignore_chirp1&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ignore_chirp1&#39;</span><span class="p">]</span>
    <span class="c1"># there must be high levels of reflection/scattering in this region to produce ghost echos</span>
    <span class="n">RG_MIN_</span><span class="p">,</span> <span class="n">RG_MAX_</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">500.0</span>  <span class="c1"># range interval</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mf">0.0</span>
    <span class="n">reflectivity_thresh</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;Z_thresh&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;Z_thresh&#39;</span><span class="p">]</span>

    <span class="c1"># check the if high signal occurred in 0m - 500m altitude (indicator for speckle ghost echos above)</span>
    <span class="n">dBZ_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">argnearest</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">RG_MIN_</span><span class="p">):</span><span class="n">argnearest</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">RG_MAX_</span><span class="p">),</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ts_to_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dBZ_max</span> <span class="o">&gt;=</span> <span class="n">z2lin</span><span class="p">(</span><span class="n">reflectivity_thresh</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">signal_min</span> <span class="o">=</span> <span class="n">z2lin</span><span class="p">(</span><span class="n">dBZ_thresh</span><span class="p">)</span>
    <span class="n">n_vel</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">iC</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vel</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">iC</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ignore_chirp1</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># exclude first chirp because ghost is hidden under real signal anyway</span>
        <span class="n">idx_max_vel_new</span> <span class="o">=</span> <span class="n">argnearest</span><span class="p">(</span><span class="n">vel</span><span class="p">[</span><span class="n">iC</span><span class="p">],</span> <span class="n">vel</span><span class="p">[</span><span class="n">iC</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">reduce_by</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iV</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_vel</span> <span class="o">-</span> <span class="n">idx_max_vel_new</span><span class="p">):</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">ts_to_mask</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="n">iC</span><span class="p">]:</span><span class="n">offset</span><span class="p">[</span><span class="n">iC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ts_to_mask</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="n">iC</span><span class="p">]:</span><span class="n">offset</span><span class="p">[</span><span class="n">iC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">iV</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">signal_min</span>
        <span class="k">for</span> <span class="n">iV</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx_max_vel_new</span><span class="p">,</span> <span class="n">n_vel</span><span class="p">):</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">ts_to_mask</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="n">iC</span><span class="p">]:</span><span class="n">offset</span><span class="p">[</span><span class="n">iC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">ts_to_mask</span><span class="p">,</span> <span class="n">offset</span><span class="p">[</span><span class="n">iC</span><span class="p">]:</span><span class="n">offset</span><span class="p">[</span><span class="n">iC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">iV</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">signal_min</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="filter_ghost_2"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.filter_ghost_2">[docs]</a><span class="k">def</span> <span class="nf">filter_ghost_2</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">rg</span><span class="p">,</span> <span class="n">SL</span><span class="p">,</span> <span class="n">first_offset</span><span class="p">,</span> <span class="n">dBZ_thresh</span><span class="o">=-</span><span class="mf">5.0</span><span class="p">,</span> <span class="n">reduce_by</span><span class="o">=</span><span class="mf">10.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function is used to remove curtain-like ghost echoes</span>
<span class="sd">    from the first chirp of RPG FMCW 94GHz cloud radar spectra.</span>

<span class="sd">    Args:</span>
<span class="sd">        data (numpy.array): cloud radar Doppler spectra, dimensions: (time, range, velocity), unit: [mm6 mm-3 m s-1]</span>
<span class="sd">        rg (numpy.array): range values, unit [m]</span>
<span class="sd">        SL (numpy.array): sensitivity limit, dimension: (time, range), unit: [mm6 mm-3]</span>
<span class="sd">        first_offset (integer): range index where the first chirp change takes place</span>
<span class="sd">        dBZ_thresh (float): minimum threshold in [dBZ], where ghost echos can be assumed</span>
<span class="sd">        reduce_by (float): reduce the sensitivity limit by this amount of [dBZ]</span>

<span class="sd">    Returns:</span>
<span class="sd">        mask (numpy.array, bool): where True = fill_value, and False = signal, dimensions: (time, range, velocity)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># there must be high levels of reflection/scattering in this region to produce ghost echos</span>
    <span class="n">RG_MIN_</span><span class="p">,</span> <span class="n">RG_MAX_</span> <span class="o">=</span> <span class="mf">1500.0</span><span class="p">,</span> <span class="mf">6000.0</span>  <span class="c1"># range interval</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">data</span> <span class="o">&lt;=</span> <span class="mf">0.0</span>

    <span class="c1"># check the if high signal occurred in 1500m - 4500m altitude (indicator for curtain like ghost echo)</span>
    <span class="n">dBZ_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">argnearest</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">RG_MIN_</span><span class="p">):</span><span class="n">argnearest</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span> <span class="n">RG_MAX_</span><span class="p">),</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ts_to_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">dBZ_max</span> <span class="o">&gt;=</span> <span class="n">z2lin</span><span class="p">(</span><span class="n">dBZ_thresh</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">sens_lim</span> <span class="o">=</span> <span class="n">SL</span> <span class="o">*</span> <span class="n">reduce_by</span>
    <span class="k">for</span> <span class="n">iT</span><span class="p">,</span> <span class="n">mask_iT</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts_to_mask</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mask_iT</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iV</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="n">mask</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:</span><span class="n">first_offset</span><span class="p">,</span> <span class="n">iV</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:</span><span class="n">first_offset</span><span class="p">,</span> <span class="n">iV</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">sens_lim</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="p">:</span><span class="n">first_offset</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">mask</span></div>


<span class="k">def</span> <span class="nf">split_by_compression_status</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">split_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">split_int</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">split_int</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>


<div class="viewcode-block" id="spectra2moments"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.spectra2moments">[docs]</a><span class="k">def</span> <span class="nf">spectra2moments</span><span class="p">(</span><span class="n">ZSpec</span><span class="p">,</span> <span class="n">paraminfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine calculates the radar moments: reflectivity, mean Doppler velocity, spectrum width, skewness and</span>
<span class="sd">    kurtosis from the level 0 spectrum files of the 94 GHz RPG cloud radar.</span>

<span class="sd">    Args:</span>
<span class="sd">        ZSpec (dict): list containing the dicts for each chrip of RPG-FMCW Doppler cloud radar</span>
<span class="sd">        paraminfo (dict): information from params_[campaign].toml for the system LIMRAD94</span>

<span class="sd">    Returns:</span>
<span class="sd">        container_dict (dict): dictionary of larda containers, including larda container for Ze, VEL, sw, skew, kurt</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># initialize variables:</span>
    <span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">,</span> <span class="n">n_vel</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_chirps</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;n_ch&#39;</span><span class="p">]</span>
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">SW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">SK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_ts</span><span class="p">,</span> <span class="n">n_rg</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="n">spec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">spec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span>
    <span class="n">spec_lin</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># combine the mask for &quot;contains signal&quot; with &quot;signal has more than 1 spectral line&quot;</span>
    <span class="n">mask1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span>
    <span class="n">mask3</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">n_vel</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask1</span> <span class="o">*</span> <span class="n">mask2</span> <span class="o">*</span> <span class="n">mask3</span>

    <span class="k">for</span> <span class="n">iC</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_chirps</span><span class="p">):</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">][</span><span class="n">iC</span><span class="p">],</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;rg_offsets&#39;</span><span class="p">][</span><span class="n">iC</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]):</span>  <span class="c1"># range dimension</span>
            <span class="k">for</span> <span class="n">iT</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ts</span><span class="p">):</span>  <span class="c1"># time dimension</span>
                <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]:</span> <span class="k">continue</span>
                <span class="n">lb</span><span class="p">,</span> <span class="n">rb</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;edges&#39;</span><span class="p">][</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">Z</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">],</span> <span class="n">V</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">],</span> <span class="n">SW</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">],</span> <span class="n">SK</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">],</span> <span class="n">K</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">]</span> <span class="o">=</span> \
                    <span class="n">radar_moment_calculation</span><span class="p">(</span><span class="n">spec_lin</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span><span class="n">rb</span><span class="p">],</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;vel&#39;</span><span class="p">][</span><span class="n">iC</span><span class="p">][</span><span class="n">lb</span><span class="p">:</span><span class="n">rb</span><span class="p">],</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;DoppRes&#39;</span><span class="p">][</span><span class="n">iC</span><span class="p">])</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Chirp </span><span class="si">{</span><span class="n">iC</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1"> Moments Calculated, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>

    <span class="n">moments</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Ze&#39;</span><span class="p">:</span> <span class="n">Z</span><span class="p">,</span> <span class="s1">&#39;VEL&#39;</span><span class="p">:</span> <span class="n">V</span><span class="p">,</span> <span class="s1">&#39;sw&#39;</span><span class="p">:</span> <span class="n">SW</span><span class="p">,</span> <span class="s1">&#39;skew&#39;</span><span class="p">:</span> <span class="n">SK</span><span class="p">,</span> <span class="s1">&#39;kurt&#39;</span><span class="p">:</span> <span class="n">K</span><span class="p">}</span>
    <span class="c1"># create the mask where invalid values have been encountered</span>
    <span class="n">invalid_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]),</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">invalid_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Z</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># despeckle the moments</span>
    <span class="k">if</span> <span class="s1">&#39;despeckle&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;despeckle&#39;</span><span class="p">]:</span>
        <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># copy and convert from bool to 0 and 1, remove a pixel  if more than 20 neighbours are invalid (5x5 grid)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">despeckle</span><span class="p">(</span><span class="n">invalid_mask</span><span class="p">,</span> <span class="mf">80.</span><span class="p">)</span>
        <span class="n">invalid_mask</span><span class="p">[</span><span class="n">new_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Despeckle done, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>

    <span class="c1"># mask invalid values with fill_value = -999.0</span>
    <span class="k">for</span> <span class="n">mom</span> <span class="ow">in</span> <span class="n">moments</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">moments</span><span class="p">[</span><span class="n">mom</span><span class="p">][</span><span class="n">invalid_mask</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">999.0</span>

    <span class="c1"># build larda containers from calculated moments</span>
    <span class="n">container_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">mom</span><span class="p">:</span> <span class="n">make_container_from_spectra</span><span class="p">([</span><span class="n">ZSpec</span><span class="p">],</span> <span class="n">moments</span><span class="p">[</span><span class="n">mom</span><span class="p">],</span> <span class="n">paraminfo</span><span class="p">[</span><span class="n">mom</span><span class="p">],</span> <span class="n">invalid_mask</span><span class="p">,</span> <span class="s1">&#39;VHSpec&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">mom</span> <span class="ow">in</span> <span class="n">moments</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

    <span class="k">return</span> <span class="n">container_dict</span></div>


<div class="viewcode-block" id="heave_correction"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.heave_correction">[docs]</a><span class="k">def</span> <span class="nf">heave_correction</span><span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">path_to_seapath</span><span class="o">=</span><span class="s2">&quot;/projekt2/remsens/data_new/site-campaign/rv_meteor-eurec4a/instruments/RV-METEOR_DSHIP&quot;</span><span class="p">,</span>
                     <span class="n">mean_hr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_heave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_cross_product</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform_to_earth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Correct mean Doppler velocity for heave motion of ship (RV-Meteor)</span>
<span class="sd">    Calculate heave rate from seapath measurements and create heave correction array. If Doppler velocity is given as an</span>
<span class="sd">    input, correct it and return an array with the corrected Doppler velocities.</span>
<span class="sd">    Without Doppler Velocity input, only the heave correction array is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        moments: LIMRAD94 moments container as returned by spectra2moments in spec2mom_limrad94.py, C1/2/3_Range,</span>
<span class="sd">                 SeqIntTime and Inc_ElA (for time (ts)) from LV1 file</span>
<span class="sd">        date (datetime.datetime): object with date of current file</span>
<span class="sd">        path_to_seapath (string): path where seapath measurement files (daily dat files) are stored</span>
<span class="sd">        mean_hr (bool): whether to use the mean heave rate over the SeqIntTime or the heave rate at the start time of the chirp</span>
<span class="sd">        only_heave (bool): whether to use only heave to calculate the heave rate or include pitch and roll induced heave</span>
<span class="sd">        use_cross_product (bool): whether to use the cross product like Hannes Griesche https://doi.org/10.5194/amt-2019-434</span>
<span class="sd">        transform_to_earth (bool): transform cross product to earth coordinate system as </span>
<span class="sd">            described in https://repository.library.noaa.gov/view/noaa/17400</span>
<span class="sd">        add (bool): whether to add the heave rate or subtract it</span>

<span class="sd">    Returns: </span>
<span class="sd">        A number of variables</span>
<span class="sd">        </span>
<span class="sd">        - **new_vel** (*ndarray*); corrected Doppler velocities, same shape as moments[&quot;VEL&quot;][&quot;var&quot;] or list if no Doppler</span>
<span class="sd">          Velocity is given;</span>
<span class="sd">        - **heave_corr** (*ndarray*): heave rate closest to each radar timestep for each height bin, same shape as</span>
<span class="sd">          moments[&quot;VEL&quot;][&quot;var&quot;];</span>
<span class="sd">        - **seapath_out** (*pd.DataFrame*): data frame with all heave information from the closest time steps to the chirps</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Data Read in</span>
    <span class="c1">####################################################################################################################</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting heave correction for </span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">seapath</span> <span class="o">=</span> <span class="n">read_seapath</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">path_to_seapath</span><span class="p">)</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Calculating Heave Rate</span>
    <span class="c1">####################################################################################################################</span>
    <span class="n">seapath</span> <span class="o">=</span> <span class="n">calc_heave_rate</span><span class="p">(</span><span class="n">seapath</span><span class="p">,</span> <span class="n">only_heave</span><span class="o">=</span><span class="n">only_heave</span><span class="p">,</span> <span class="n">use_cross_product</span><span class="o">=</span><span class="n">use_cross_product</span><span class="p">,</span>
                              <span class="n">transform_to_earth</span><span class="o">=</span><span class="n">transform_to_earth</span><span class="p">)</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Calculating heave correction array and add to Doppler velocity</span>
    <span class="c1">####################################################################################################################</span>
    <span class="c1"># make input container to calc_heave_corr function</span>
    <span class="n">container</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C1Range&#39;</span><span class="p">:</span> <span class="n">moments</span><span class="p">[</span><span class="s1">&#39;C1Range&#39;</span><span class="p">],</span> <span class="s1">&#39;C2Range&#39;</span><span class="p">:</span> <span class="n">moments</span><span class="p">[</span><span class="s1">&#39;C2Range&#39;</span><span class="p">],</span> <span class="s1">&#39;C3Range&#39;</span><span class="p">:</span> <span class="n">moments</span><span class="p">[</span><span class="s1">&#39;C3Range&#39;</span><span class="p">],</span>
                 <span class="s1">&#39;SeqIntTime&#39;</span><span class="p">:</span> <span class="n">moments</span><span class="p">[</span><span class="s1">&#39;SeqIntTime&#39;</span><span class="p">],</span> <span class="s1">&#39;ts&#39;</span><span class="p">:</span> <span class="n">moments</span><span class="p">[</span><span class="s1">&#39;Inc_ElA&#39;</span><span class="p">][</span><span class="s1">&#39;ts&#39;</span><span class="p">]}</span>
    <span class="n">heave_corr</span><span class="p">,</span> <span class="n">seapath_out</span> <span class="o">=</span> <span class="n">calc_heave_corr</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">seapath</span><span class="p">,</span> <span class="n">mean_hr</span><span class="o">=</span><span class="n">mean_hr</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">add</span><span class="p">:</span>
            <span class="c1"># create new Doppler velocity by adding the heave rate of the closest time step</span>
            <span class="n">new_vel</span> <span class="o">=</span> <span class="n">moments</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">heave_corr</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">add</span><span class="p">:</span>
            <span class="c1"># create new Doppler velocity by subtracting the heave rate of the closest time step</span>
            <span class="n">new_vel</span> <span class="o">=</span> <span class="n">moments</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">heave_corr</span>
        <span class="c1"># set masked values back to -999 because they also get corrected</span>
        <span class="n">new_vel</span><span class="p">[</span><span class="n">moments</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">][</span><span class="s1">&#39;mask&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with heave corrections in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_vel</span><span class="p">,</span> <span class="n">heave_corr</span><span class="p">,</span> <span class="n">seapath_out</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No input Velocities found! Cannot correct Doppler Velocity.</span><span class="se">\n</span><span class="s2"> Returning only heave_corr array!&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with heave correction calculation only in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        <span class="n">new_vel</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&#39;m an empty list!&quot;</span><span class="p">]</span>  <span class="c1"># create an empty list to return the same number of variables</span>
        <span class="k">return</span> <span class="n">new_vel</span><span class="p">,</span> <span class="n">heave_corr</span><span class="p">,</span> <span class="n">seapath_out</span></div>


<div class="viewcode-block" id="heave_correction_spectra"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.heave_correction_spectra">[docs]</a><span class="k">def</span> <span class="nf">heave_correction_spectra</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span>
                             <span class="n">path_to_seapath</span><span class="o">=</span><span class="s2">&quot;/projekt2/remsens/data_new/site-campaign/rv_meteor-eurec4a/instruments/RV-METEOR_DSHIP&quot;</span><span class="p">,</span>
                             <span class="n">mean_hr</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_heave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_cross_product</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">transform_to_earth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">add</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shift Doppler spectra to correct for heave motion of ship (RV-Meteor)</span>
<span class="sd">    Calculate heave rate from seapath measurements and create heave correction array. Translate the heave correction to</span>
<span class="sd">    a number spectra bins by which to move each spectra. If Spectra are given, shift them and return a 3D array with the</span>
<span class="sd">    shifted spectra.</span>
<span class="sd">    Without spectra input, only the heave correction array and the array with the number if bins to move is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        data: LIMRAD94 data container filled with spectra and C1/2/3_Range, SeqIntTime, MaxVel, DoppLen from LV1 file;</span>
<span class="sd">            for Claudia&#39;s version the mean Doppler velocity is also needed</span>
<span class="sd">        date (datetime.datetime): object with date of current file</span>
<span class="sd">        path_to_seapath (string): path where seapath measurement files (daily dat files) are stored</span>
<span class="sd">        mean_hr (bool): whether to use the mean heave rate over the SeqIntTime or the heave rate at the start time of the chirp</span>
<span class="sd">        only_heave (bool): whether to use only heave to calculate the heave rate or include pitch and roll induced heave</span>
<span class="sd">        use_cross_product (bool): whether to use the cross product like Hannes Griesche https://doi.org/10.5194/amt-2019-434</span>
<span class="sd">        transform_to_earth (bool): transform cross product to earth coordinate system as described in https://repository.library.noaa.gov/view/noaa/17400</span>
<span class="sd">        add (bool): whether to add the heave rate or subtract it</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            shift (int): number of time steps to shift seapath data</span>
<span class="sd">            version (str): which version to use, &#39;ca&#39; or &#39;jr&#39;</span>

<span class="sd">    Returns: </span>
<span class="sd">        A number of variables</span>
<span class="sd">        </span>
<span class="sd">        - **new_spectra** (*ndarray*); corrected Doppler velocities, same shape as data[&quot;VHSpec&quot;][&quot;var&quot;] or list if no Doppler</span>
<span class="sd">          Spectra are given;</span>
<span class="sd">        - **heave_corr** (*ndarray*): heave rate closest to each radar timestep for each height bin, shape = (time x range);</span>
<span class="sd">        - **seapath_out** (*pd.DataFrame*): data frame with all heave information from the closest time steps to the chirps</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># unpack kwargs</span>
    <span class="n">version</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;version&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;version&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="s1">&#39;jr&#39;</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;shift&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;shift&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Data Read in</span>
    <span class="c1">####################################################################################################################</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Starting heave correction for </span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s2">%Y-%m-%d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;ca&#39;</span><span class="p">:</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">read_seapath</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">path_to_seapath</span><span class="p">,</span> <span class="n">output_format</span><span class="o">=</span><span class="s1">&#39;xarray&#39;</span><span class="p">)</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">f_shiftTimeDataset</span><span class="p">(</span><span class="n">seapath</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;jr&#39;</span><span class="p">:</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">read_seapath</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">path_to_seapath</span><span class="p">)</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Calculating Heave Rate</span>
    <span class="c1">####################################################################################################################</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;ca&#39;</span><span class="p">:</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">calc_heave_rate_claudia</span><span class="p">(</span><span class="n">seapath</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;jr&#39;</span><span class="p">:</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">calc_heave_rate</span><span class="p">(</span><span class="n">seapath</span><span class="p">,</span> <span class="n">only_heave</span><span class="o">=</span><span class="n">only_heave</span><span class="p">,</span> <span class="n">use_cross_product</span><span class="o">=</span><span class="n">use_cross_product</span><span class="p">,</span>
                                  <span class="n">transform_to_earth</span><span class="o">=</span><span class="n">transform_to_earth</span><span class="p">)</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Calculate time shift between radar and ship and shift radar time or seapath time depending on version</span>
    <span class="c1">####################################################################################################################</span>
    <span class="n">chirp_ts</span> <span class="o">=</span> <span class="n">calc_chirp_timestamps</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;ts&#39;</span><span class="p">],</span> <span class="n">date</span><span class="p">,</span> <span class="n">version</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
    <span class="n">rg_borders</span> <span class="o">=</span> <span class="n">get_range_bin_borders</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="c1"># transform bin boundaries, necessary because python starts counting at 0</span>
    <span class="n">rg_borders_id</span> <span class="o">=</span> <span class="n">rg_borders</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="c1"># setting the length of the mean doppler velocity time series for calculating time shift</span>
    <span class="n">n_ts_run</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">/</span> <span class="mf">1.5</span><span class="p">)</span>  <span class="c1"># 10 minutes with time res of 1.5 s</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;ca&#39;</span><span class="p">:</span>
        <span class="c1"># here seapath is a xarray DataSet</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="s1">&#39;time_shifted&#39;</span><span class="p">)</span>  <span class="c1"># drop nans for interpolation</span>
        <span class="n">seapath_time</span> <span class="o">=</span> <span class="n">seapath</span><span class="p">[</span><span class="s1">&#39;time_shifted&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span>  <span class="c1"># get nan free time in seconds</span>
    <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;jr&#39;</span><span class="p">:</span>
        <span class="c1"># here seapath is a pandas DataFrame</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
        <span class="n">seapath_time</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span>  <span class="c1"># get nan free time in seconds</span>
    <span class="c1"># prepare interpolation function for angular velocity</span>
    <span class="n">Cs</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span><span class="n">seapath_time</span><span class="p">,</span> <span class="n">seapath</span><span class="p">[</span><span class="s1">&#39;heave_rate_radar&#39;</span><span class="p">])</span>
    <span class="n">plot_path</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;/projekt2/remsens/data_new/site-campaign/rv_meteor-eurec4a/instruments/LIMRAD94/cloudnet_input_heave_cor_</span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s1">/time_shift_plots&#39;</span>
    <span class="n">delta_t_min</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.</span>  <span class="c1"># minimum time shift</span>
    <span class="n">delta_t_max</span> <span class="o">=</span> <span class="mf">3.</span>  <span class="c1"># maximum time shift</span>

    <span class="c1"># find a 10 minute mdv time series in every hour of radar data and for each chirp if possible</span>
    <span class="c1"># calculate time shift for each hour and each chirp</span>
    <span class="n">chirp_ts_shifted</span><span class="p">,</span> <span class="n">time_shift_array</span> <span class="o">=</span> <span class="n">calc_shifted_chirp_timestamps</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;mdv&#39;</span><span class="p">][</span><span class="s1">&#39;ts&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mdv&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">],</span>
                                                                       <span class="n">chirp_ts</span><span class="p">,</span> <span class="n">rg_borders_id</span><span class="p">,</span> <span class="n">n_ts_run</span><span class="p">,</span> <span class="n">Cs</span><span class="p">,</span>
                                                                       <span class="n">no_chirps</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">pathFig</span><span class="o">=</span><span class="n">plot_path</span><span class="p">,</span>
                                                                       <span class="n">delta_t_min</span><span class="o">=</span><span class="n">delta_t_min</span><span class="p">,</span>
                                                                       <span class="n">delta_t_max</span><span class="o">=</span><span class="n">delta_t_max</span><span class="p">,</span>
                                                                       <span class="n">date</span><span class="o">=</span><span class="n">date</span><span class="p">,</span> <span class="n">plot_fig</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">shift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">shift_seapath</span><span class="p">(</span><span class="n">seapath</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shift is </span><span class="si">{</span><span class="n">shift</span><span class="si">}</span><span class="s2">! Seapath data is not shifted!&quot;</span><span class="p">)</span>
    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Calculating heave correction array and translate to number of Doppler bin shifts</span>
    <span class="c1">####################################################################################################################</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;ca&#39;</span><span class="p">:</span>
        <span class="c1"># calculate the correction matrix</span>
        <span class="n">heave_corr</span> <span class="o">=</span> <span class="n">calc_corr_matrix_claudia</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;mdv&#39;</span><span class="p">][</span><span class="s1">&#39;ts&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;mdv&#39;</span><span class="p">][</span><span class="s1">&#39;rg&#39;</span><span class="p">],</span> <span class="n">rg_borders_id</span><span class="p">,</span> <span class="n">chirp_ts_shifted</span><span class="p">,</span> <span class="n">Cs</span><span class="p">)</span>
        <span class="n">seapath_out</span> <span class="o">=</span> <span class="n">seapath</span>
    <span class="k">elif</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;jr&#39;</span><span class="p">:</span>
        <span class="c1"># make input container for calc_heave_corr function</span>
        <span class="n">container</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C1Range&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;C1Range&#39;</span><span class="p">],</span> <span class="s1">&#39;C2Range&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;C2Range&#39;</span><span class="p">],</span> <span class="s1">&#39;C3Range&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;C3Range&#39;</span><span class="p">],</span>
                     <span class="s1">&#39;SeqIntTime&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;SeqIntTime&#39;</span><span class="p">],</span> <span class="s1">&#39;ts&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;ts&#39;</span><span class="p">],</span> <span class="s1">&#39;MaxVel&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;MaxVel&#39;</span><span class="p">],</span>
                     <span class="s1">&#39;DoppLen&#39;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;DoppLen&quot;</span><span class="p">]}</span>
        <span class="n">heave_corr</span><span class="p">,</span> <span class="n">seapath_out</span> <span class="o">=</span> <span class="n">calc_heave_corr</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">chirp_ts_shifted</span><span class="p">,</span> <span class="n">seapath</span><span class="p">,</span> <span class="n">mean_hr</span><span class="o">=</span><span class="n">mean_hr</span><span class="p">)</span>

    <span class="n">no_chirps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;DoppLen&#39;</span><span class="p">])</span>
    <span class="n">range_bins</span> <span class="o">=</span> <span class="n">get_range_bin_borders</span><span class="p">(</span><span class="n">no_chirps</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="n">doppler_res</span> <span class="o">=</span> <span class="n">calc_dopp_res</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;MaxVel&#39;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;DoppLen&#39;</span><span class="p">],</span> <span class="n">no_chirps</span><span class="p">,</span> <span class="n">range_bins</span><span class="p">)</span>

    <span class="n">n_dopp_bins_shift</span><span class="p">,</span> <span class="n">heave_corr</span> <span class="o">=</span> <span class="n">heave_rate_to_spectra_bins</span><span class="p">(</span><span class="n">heave_corr</span><span class="p">,</span> <span class="n">doppler_res</span><span class="p">)</span>

    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Shifting spectra and writing to new 3D array</span>
    <span class="c1">####################################################################################################################</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># correct spectra for heave rate by moving it by the corresponding number of Doppler bins</span>
        <span class="n">spectra</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span>
        <span class="n">new_spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">spectra</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">iT</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_ts&#39;</span><span class="p">]):</span>
            <span class="c1"># loop through time steps</span>
            <span class="k">for</span> <span class="n">iR</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;n_rg&#39;</span><span class="p">]):</span>
                <span class="c1"># loop through range gates</span>
                <span class="c1"># TODO: check if mask is True and skip, although masked shifted spectra do not introduce any error,</span>
                <span class="c1"># this might speed up things...</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n_dopp_bins_shift</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;shift at [</span><span class="si">{</span><span class="n">iT</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">iR</span><span class="si">}</span><span class="s2">] is NaN, set to zero&quot;</span><span class="p">)</span>
                    <span class="n">shift</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span>
                <span class="k">if</span> <span class="n">add</span><span class="p">:</span>
                    <span class="n">new_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">add</span><span class="p">:</span>
                    <span class="n">new_spec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="o">-</span><span class="n">shift</span><span class="p">)</span>

                <span class="n">new_spectra</span><span class="p">[</span><span class="n">iT</span><span class="p">,</span> <span class="n">iR</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">new_spec</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with heave corrections in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new_spectra</span><span class="p">,</span> <span class="n">heave_corr</span><span class="p">,</span> <span class="n">n_dopp_bins_shift</span><span class="p">,</span> <span class="n">seapath_out</span><span class="p">,</span> <span class="n">time_shift_array</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No input spectra found! Cannot shift spectra.</span><span class="se">\n</span><span class="s2"> Returning only heave_corr and n_dopp_bins_shift array!&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with heave correction calculation only in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
        <span class="n">new_spectra</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;I&#39;m an empty list!&quot;</span><span class="p">]</span>  <span class="c1"># create an empty list to return the same number of variables</span>
        <span class="k">return</span> <span class="n">new_spectra</span><span class="p">,</span> <span class="n">heave_corr</span><span class="p">,</span> <span class="n">n_dopp_bins_shift</span><span class="p">,</span> <span class="n">seapath_out</span><span class="p">,</span> <span class="n">time_shift_array</span></div>


<div class="viewcode-block" id="read_seapath"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.read_seapath">[docs]</a><span class="k">def</span> <span class="nf">read_seapath</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s2">&quot;/projekt2/remsens/data_new/site-campaign/rv_meteor-eurec4a/instruments/RV-METEOR_DSHIP&quot;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Read in daily Seapath measurements from RV Meteor from .dat files to a pandas.DataFrame</span>
<span class="sd">    Args:</span>
<span class="sd">        date (datetime.datetime): object with date of current file</span>
<span class="sd">        path (str): path to seapath files</span>
<span class="sd">        kwargs for read_csv</span>
<span class="sd">            output_format (str): whether a pandas data frame or a xarray dataset is returned</span>

<span class="sd">    Returns:</span>
<span class="sd">        seapath (DataFrame): DataFrame with Seapath measurements</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Seapath attitude and heave data 1 or 10 Hz, choose file depending on date</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># unpack kwargs</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nrows&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;nrows&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">skiprows</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;skiprows&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;skiprows&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">output_format</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;output_format&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;output_format&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="s1">&#39;pandas&#39;</span>
    <span class="k">if</span> <span class="n">date</span> <span class="o">&lt;</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">27</span><span class="p">):</span>
        <span class="n">file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s2">%Y%m%d</span><span class="si">}</span><span class="s2">_DSHIP_seapath_1Hz.dat&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s2">%Y%m%d</span><span class="si">}</span><span class="s2">_DSHIP_seapath_10Hz.dat&quot;</span>
    <span class="c1"># set encoding and separator, skip the rows with the unit and type of measurement</span>
    <span class="n">seapath</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">file</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;windows-1252&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="n">skiprows</span><span class="p">,</span> <span class="n">na_values</span><span class="o">=-</span><span class="mf">999.00</span><span class="p">,</span>
                          <span class="n">index_col</span><span class="o">=</span><span class="s1">&#39;date time&#39;</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">)</span>
    <span class="c1"># transform index to datetime</span>
    <span class="n">seapath</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">infer_datetime_format</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;time&#39;</span>
    <span class="n">seapath</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;yaw&#39;</span><span class="p">,</span> <span class="s1">&#39;heave&#39;</span><span class="p">,</span> <span class="s1">&#39;pitch&#39;</span><span class="p">,</span> <span class="s1">&#39;roll&#39;</span><span class="p">]</span>  <span class="c1"># rename columns</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done reading in Seapath data in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;pandas&#39;</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">elif</span> <span class="n">output_format</span> <span class="o">==</span> <span class="s1">&#39;xarray&#39;</span><span class="p">:</span>
        <span class="n">seapath</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">to_xarray</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">seapath</span></div>


<div class="viewcode-block" id="read_dship"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.read_dship">[docs]</a><span class="k">def</span> <span class="nf">read_dship</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read in 1 Hz DSHIP data and return pandas DataFrame</span>

<span class="sd">    Args:</span>
<span class="sd">        date (str): yyyymmdd (eg. 20200210)</span>
<span class="sd">        **kwargs: kwargs for pd.read_csv (not all implemented) https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_csv.html</span>

<span class="sd">    Returns: </span>
<span class="sd">        pd.DataFrame with 1 Hz DSHIP data</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;path&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="s2">&quot;/projekt2/remsens/data_new/site-campaign/rv_meteor-eurec4a/instruments/RV-METEOR_DSHIP&quot;</span>
    <span class="n">skiprows</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;skiprows&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;skiprows&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">nrows</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;nrows&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;nrows&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">cols</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cols&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;cols&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">None</span>  <span class="c1"># always keep the 0th column (datetime column)</span>
    <span class="n">file</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2">/RV-Meteor_DSHIP_all_1Hz_</span><span class="si">{</span><span class="n">date</span><span class="si">}</span><span class="s2">.dat&quot;</span>
    <span class="c1"># set encoding and separator, skip the rows with the unit and type of measurement, set index column</span>
    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;windows-1252&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="n">skiprows</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="s1">&#39;date time&#39;</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span>
                     <span class="n">usecols</span><span class="o">=</span><span class="n">cols</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">infer_datetime_format</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done reading in DSHIP data in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span></div>


<div class="viewcode-block" id="f_shiftTimeDataset"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.f_shiftTimeDataset">[docs]</a><span class="k">def</span> <span class="nf">f_shiftTimeDataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    author: Claudia Acquistapace</span>
<span class="sd">    date: 25 november 2020</span>
<span class="sd">    goal : function to shift time variable of the dataset to the central value of the time interval</span>
<span class="sd">    of the time step</span>
<span class="sd">    input:</span>
<span class="sd">        dataset: xarray dataset</span>
<span class="sd">    output:</span>
<span class="sd">        dataset: xarray dataset with the time coordinate shifted added to the coordinates and the variables now referring to the shifted time array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># reading time array</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="c1"># calculating deltaT using consecutive time stamps</span>
    <span class="n">deltaT</span> <span class="o">=</span> <span class="n">time</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># print(&#39;delta T for the selected dataset: &#39;, deltaT)</span>
    <span class="c1"># defining additional coordinate to the dataset</span>
    <span class="n">dataset</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s1">&#39;time_shifted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">deltaT</span>
    <span class="c1"># exchanging coordinates in the dataset</span>
    <span class="n">datasetNew</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">swap_dims</span><span class="p">({</span><span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="s1">&#39;time_shifted&#39;</span><span class="p">})</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">datasetNew</span><span class="p">)</span></div>


<div class="viewcode-block" id="calc_heave_rate"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.calc_heave_rate">[docs]</a><span class="k">def</span> <span class="nf">calc_heave_rate</span><span class="p">(</span><span class="n">seapath</span><span class="p">,</span> <span class="n">x_radar</span><span class="o">=-</span><span class="mi">11</span><span class="p">,</span> <span class="n">y_radar</span><span class="o">=</span><span class="mf">4.07</span><span class="p">,</span> <span class="n">z_radar</span><span class="o">=</span><span class="mf">15.8</span><span class="p">,</span> <span class="n">only_heave</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_cross_product</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">transform_to_earth</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate heave rate at a certain location of a ship with the measurements of the INS</span>

<span class="sd">    Args:</span>
<span class="sd">        seapath (pd.DataFrame): Data frame with heading, roll, pitch and heave as columns</span>
<span class="sd">        x_radar (float): x position of location with respect to INS in meters</span>
<span class="sd">        y_radar (float): y position of location with respect to INS in meters</span>
<span class="sd">        z_radar (float): z position of location with respect to INS in meters</span>
<span class="sd">        only_heave (bool): whether to use only heave to calculate the heave rate or include pitch and roll induced heave</span>
<span class="sd">        use_cross_product (bool): whether to use the cross product like Hannes Griesche https://doi.org/10.5194/amt-2019-434</span>
<span class="sd">        transform_to_earth (bool): transform cross product to earth coordinate system as described in https://repository.library.noaa.gov/view/noaa/17400</span>

<span class="sd">    Returns:</span>
<span class="sd">        seapath (pd.DataFrame): Data frame as input with additional columns radar_heave, pitch_heave, roll_heave and</span>
<span class="sd">        &quot;heave_rate&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Calculating Heave Rate...&quot;</span><span class="p">)</span>
    <span class="c1"># angles in radians</span>
    <span class="n">pitch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;pitch&quot;</span><span class="p">])</span>
    <span class="n">roll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;roll&quot;</span><span class="p">])</span>
    <span class="n">yaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;yaw&quot;</span><span class="p">])</span>
    <span class="c1"># time delta between two time steps in seconds</span>
    <span class="n">d_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1e9</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">use_cross_product</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;using a simple geometric approach&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">only_heave</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;using also the roll and pitch induced heave&quot;</span><span class="p">)</span>
            <span class="n">pitch_heave</span> <span class="o">=</span> <span class="n">x_radar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span>
            <span class="n">roll_heave</span> <span class="o">=</span> <span class="n">y_radar</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">roll</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">only_heave</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;using only the ships heave&quot;</span><span class="p">)</span>
            <span class="n">pitch_heave</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">roll_heave</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># sum up heave, pitch induced and roll induced heave</span>
        <span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;radar_heave&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;heave&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">pitch_heave</span> <span class="o">+</span> <span class="n">roll_heave</span>
        <span class="c1"># add pitch and roll induced heave to data frame to include in output for quality checking</span>
        <span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;pitch_heave&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pitch_heave</span>
        <span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;roll_heave&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">roll_heave</span>
        <span class="c1"># ediff1d calculates the difference between consecutive elements of an array</span>
        <span class="c1"># heave difference / time difference = heave rate</span>
        <span class="n">heave_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;radar_heave&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_t</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Using the cross product approach from Hannes Griesche&quot;</span><span class="p">)</span>
        <span class="c1"># change of angles with time</span>
        <span class="n">d_roll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">roll</span><span class="p">)</span> <span class="o">/</span> <span class="n">d_t</span>  <span class="c1"># phi</span>
        <span class="n">d_pitch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">pitch</span><span class="p">)</span> <span class="o">/</span> <span class="n">d_t</span>  <span class="c1"># theta</span>
        <span class="n">d_yaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">yaw</span><span class="p">)</span> <span class="o">/</span> <span class="n">d_t</span>  <span class="c1"># psi</span>
        <span class="n">seapath_heave_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">seapath</span><span class="p">[</span><span class="s2">&quot;heave&quot;</span><span class="p">])</span> <span class="o">/</span> <span class="n">d_t</span>  <span class="c1"># heave rate at seapath</span>
        <span class="n">pos_radar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_radar</span><span class="p">,</span> <span class="n">y_radar</span><span class="p">,</span> <span class="n">z_radar</span><span class="p">])</span>  <span class="c1"># position of radar as a vector</span>
        <span class="n">ang_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">d_roll</span><span class="p">,</span> <span class="n">d_pitch</span><span class="p">,</span> <span class="n">d_yaw</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>  <span class="c1"># angle velocity as a matrix</span>
        <span class="n">pos_radar_exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">pos_radar</span><span class="p">,</span> <span class="p">(</span><span class="n">ang_rate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># expand to shape of ang_rate</span>
        <span class="n">cross_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">ang_rate</span><span class="p">,</span> <span class="n">pos_radar_exp</span><span class="p">)</span>  <span class="c1"># calculate cross product</span>

        <span class="k">if</span> <span class="n">transform_to_earth</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Transform into Earth Coordinate System&quot;</span><span class="p">)</span>
            <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">psi</span> <span class="o">=</span> <span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span>
            <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
            <span class="n">a2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">a3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
            <span class="n">b2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
            <span class="n">b3</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>
            <span class="n">c1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">c3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
            <span class="n">Q_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">],</span> <span class="p">[</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">b3</span><span class="p">],</span> <span class="p">[</span><span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span><span class="p">]])</span>
            <span class="c1"># remove first entry of Q_T to match dimension of cross_prod</span>
            <span class="n">Q_T</span> <span class="o">=</span> <span class="n">Q_T</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">cross_prod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijk,kj-&gt;kj&#39;</span><span class="p">,</span> <span class="n">Q_T</span><span class="p">,</span> <span class="n">cross_prod</span><span class="p">)</span>

        <span class="n">heave_rate</span> <span class="o">=</span> <span class="n">seapath_heave_rate</span> <span class="o">+</span> <span class="n">cross_prod</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># calculate heave rate</span>

    <span class="c1"># add heave rate to seapath data frame</span>
    <span class="c1"># the first calculated heave rate corresponds to the second time step</span>
    <span class="n">heave_rate</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;heave_rate_radar&#39;</span><span class="p">:</span> <span class="n">heave_rate</span><span class="p">},</span> <span class="n">index</span><span class="o">=</span><span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">seapath</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">heave_rate</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with heave rate calculation in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t1</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">seapath</span></div>

<div class="viewcode-block" id="f_calcRMatrix"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.f_calcRMatrix">[docs]</a><span class="k">def</span> <span class="nf">f_calcRMatrix</span><span class="p">(</span><span class="n">rollShipArr</span><span class="p">,</span> <span class="n">pitchShipArr</span><span class="p">,</span> <span class="n">yawShipArr</span><span class="p">,</span> <span class="n">NtimeShip</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    author: Claudia Acquistapace</span>
<span class="sd">    date : 27/10/2020</span>
<span class="sd">    goal: function to calculate R matrix given roll, pitch, yaw</span>
<span class="sd">    input:</span>
<span class="sd">        rollShipArr: roll array in degrees</span>
<span class="sd">        pitchShipArr: pitch array in degrees</span>
<span class="sd">        yawShipArr: yaw array in degrees</span>
<span class="sd">        NtimeShip: dimension of time array for the definition of R_inv as [3,3,dimTime]</span>
<span class="sd">    output:</span>
<span class="sd">        R[3,3,Dimtime]: array of rotational matrices, one for each time stamp</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># calculation of the rotational matrix for each time stamp of the ship data for the day</span>
    <span class="n">cosTheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">rollShipArr</span><span class="p">))</span>
    <span class="n">senTheta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">rollShipArr</span><span class="p">))</span>
    <span class="n">cosPhi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">pitchShipArr</span><span class="p">))</span>
    <span class="n">senPhi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">pitchShipArr</span><span class="p">))</span>
    <span class="n">cosPsi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">yawShipArr</span><span class="p">))</span>
    <span class="n">senPsi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">yawShipArr</span><span class="p">))</span>

    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">NtimeShip</span><span class="p">])</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">NtimeShip</span><span class="p">])</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">NtimeShip</span><span class="p">])</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">NtimeShip</span><span class="p">])</span>
    <span class="n">R</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">A</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="n">B</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="n">C</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>

    <span class="c1"># indexing for the matrices</span>
    <span class="c1"># [0,0]  [0,1]  [0,2]</span>
    <span class="c1"># [1,0]  [1,1]  [1,2]</span>
    <span class="c1"># [2,0]  [2,1]  [2,2]</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cosTheta</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">senTheta</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">senTheta</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cosTheta</span>

    <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cosPhi</span>
    <span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cosPhi</span>
    <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">senPhi</span>
    <span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">senPhi</span>

    <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cosPsi</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">senPsi</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">senPsi</span>
    <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cosPsi</span>

    <span class="c1"># calculation of the rotation matrix</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">A</span><span class="p">))</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="calc_heave_rate_claudia"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.calc_heave_rate_claudia">[docs]</a><span class="k">def</span> <span class="nf">calc_heave_rate_claudia</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x_radar</span><span class="o">=-</span><span class="mi">11</span><span class="p">,</span> <span class="n">y_radar</span><span class="o">=</span><span class="mf">4.07</span><span class="p">,</span> <span class="n">z_radar</span><span class="o">=-</span><span class="mf">15.8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate heave rate at a certain location on a ship according to Claudia Acquistapace&#39;s approach</span>

<span class="sd">    Args:</span>
<span class="sd">        data (xr.DataSet): Data Set with heading, roll, pitch and heave as columns</span>
<span class="sd">        x_radar (float): x position of location with respect to INS in meters</span>
<span class="sd">        y_radar (float): y position of location with respect to INS in meters</span>
<span class="sd">        z_radar (float): z position of location with respect to INS in meters</span>

<span class="sd">    Returns: xr.DataSet with additional variable heave_rate</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r_radar</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_radar</span><span class="p">,</span> <span class="n">y_radar</span><span class="p">,</span> <span class="n">z_radar</span><span class="p">]</span>
    <span class="c1"># calculation of w_ship</span>
    <span class="n">heave</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;heave&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">timeShip</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;time_shifted&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float64&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span>
    <span class="n">w_ship</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">heave</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">timeShip</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># calculating rotational terms</span>
    <span class="n">roll</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;roll&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">pitch</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;pitch&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">yaw</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;yaw&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">NtimeShip</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">timeShip</span><span class="p">)</span>
    <span class="n">r_ship</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="n">NtimeShip</span><span class="p">))</span>

    <span class="c1"># calculate the position of the  radar on the ship r_ship:</span>
    <span class="n">R</span> <span class="o">=</span> <span class="n">f_calcRMatrix</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">,</span> <span class="n">NtimeShip</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">NtimeShip</span><span class="p">):</span>
        <span class="n">r_ship</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">r_radar</span><span class="p">)</span>

    <span class="c1"># calculating vertical component of the velocity of the radar on the ship (v_rot)</span>
    <span class="n">w_rot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">r_ship</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span> <span class="n">prepend</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">timeShip</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="c1"># calculating total ship velocity at radar</span>
    <span class="n">heave_rate</span> <span class="o">=</span> <span class="n">w_rot</span> <span class="o">+</span> <span class="n">w_ship</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;w_rot&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;time_shifted&#39;</span><span class="p">),</span> <span class="n">w_rot</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;heave_rate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;time_shifted&#39;</span><span class="p">),</span> <span class="n">w_ship</span><span class="p">)</span>
    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;heave_rate_radar&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="s1">&#39;time_shifted&#39;</span><span class="p">,),</span> <span class="n">heave_rate</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="find_mdv_time_series"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.find_mdv_time_series">[docs]</a><span class="k">def</span> <span class="nf">find_mdv_time_series</span><span class="p">(</span><span class="n">mdv_values</span><span class="p">,</span> <span class="n">radar_time</span><span class="p">,</span> <span class="n">n_ts_run</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    author: Claudia Acquistapace, Johannes Roettenbacher</span>
<span class="sd">    Identify, given a mean doppler velocity matrix, a sequence of length n_ts_run of values in the matrix</span>
<span class="sd">    at a given height that contains the minimum possible amount of nan values in it.</span>

<span class="sd">    Args:</span>
<span class="sd">        mdv_values (ndarray): time x heigth matrix of Doppler Velocity</span>
<span class="sd">        radar_time (ndarray): corresponding radar time stamps in seconds (unix time)</span>
<span class="sd">        n_ts_run (int): number of timestamps needed in a mdv series</span>

<span class="sd">    Returns:</span>
<span class="sd">        valuesTimeSerie (ndarray): time series of Doppler velocity with length n_ts_run</span>
<span class="sd">        time_series (ndarray): corresponding time stamps to Doppler velocity time series</span>
<span class="sd">        i_height_sel (int): index of chosen height</span>
<span class="sd">        valuesColumnMean (ndarray): time series of mean Doppler velocity averaged over height with length n_ts_run</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#  concept: scan the matrix using running mean for every height, and check the number of nans in the selected serie.</span>
    <span class="n">nanAmountMatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">mdv_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_ts_run</span><span class="p">,</span> <span class="n">mdv_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">nanAmountMatrix</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">indtime</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mdv_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n_ts_run</span><span class="p">):</span>
        <span class="n">mdvChunk</span> <span class="o">=</span> <span class="n">mdv_values</span><span class="p">[</span><span class="n">indtime</span><span class="p">:</span><span class="n">indtime</span> <span class="o">+</span> <span class="n">n_ts_run</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># count number of nans in each height</span>
        <span class="n">nanAmountMatrix</span><span class="p">[</span><span class="n">indtime</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mdvChunk</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># find indeces where nanAmount is minimal</span>
    <span class="n">ntuples</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nanAmountMatrix</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">nanAmountMatrix</span><span class="p">))</span>
    <span class="n">i_time_sel</span> <span class="o">=</span> <span class="n">ntuples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">i_height_sel</span> <span class="o">=</span> <span class="n">ntuples</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># extract corresponding time series of mean Doppler velocity values for the chirp</span>
    <span class="n">valuesTimeSerie</span> <span class="o">=</span> <span class="n">mdv_values</span><span class="p">[</span><span class="n">i_time_sel</span><span class="p">:</span><span class="n">i_time_sel</span> <span class="o">+</span> <span class="n">n_ts_run</span><span class="p">,</span> <span class="n">i_height_sel</span><span class="p">]</span>
    <span class="n">time_series</span> <span class="o">=</span> <span class="n">radar_time</span><span class="p">[</span><span class="n">i_time_sel</span><span class="p">:</span><span class="n">i_time_sel</span> <span class="o">+</span> <span class="n">n_ts_run</span><span class="p">]</span>

    <span class="c1">###### adding test for columns ########</span>
    <span class="n">valuesColumn</span> <span class="o">=</span> <span class="n">mdv_values</span><span class="p">[</span><span class="n">i_time_sel</span><span class="p">:</span><span class="n">i_time_sel</span> <span class="o">+</span> <span class="n">n_ts_run</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">valuesColumnMean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">valuesColumn</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">valuesTimeSerie</span><span class="p">,</span> <span class="n">time_series</span><span class="p">,</span> <span class="n">i_height_sel</span><span class="p">,</span> <span class="n">valuesColumnMean</span></div>


<div class="viewcode-block" id="calc_time_shift"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.calc_time_shift">[docs]</a><span class="k">def</span> <span class="nf">calc_time_shift</span><span class="p">(</span><span class="n">w_radar_meanCol</span><span class="p">,</span> <span class="n">delta_t_min</span><span class="p">,</span> <span class="n">delta_t_max</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">w_ship_chirp</span><span class="p">,</span> <span class="n">timeSerieRadar</span><span class="p">,</span> <span class="n">pathFig</span><span class="p">,</span> <span class="n">chirp</span><span class="p">,</span>
                    <span class="n">hour</span><span class="p">,</span> <span class="n">date</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    author: Claudia Acquistapace, Jan. H. Schween, Johannes Roettenbacher</span>
<span class="sd">    goal:   calculate and estimation of the time lag between the radar time stamps and the ship time stamp</span>

<span class="sd">    NOTE: adding or subtracting the obtained time shift depends on what you did</span>
<span class="sd">    during the calculation of the covariances: if you added/subtracted time _shift</span>
<span class="sd">    to t_radar you have to do the same for the &#39;exact time&#39;</span>
<span class="sd">    Here is the time shift analysis as plot:</span>
<span class="sd">    &lt;ww&gt; is short for &lt;w&#39;_ship*w&#39;_radar&gt; i.e. covariance between vertical speeds from</span>
<span class="sd">    ship movements and radar its maximum gives an estimate for optimal agreement in</span>
<span class="sd">    vertical velocities of ship and radar</span>
<span class="sd">    &lt;Delta w^2&gt; is short for &lt;(w[i]-w[i-1])^2&gt; where w = w_rad - 2*w_ship - this</span>
<span class="sd">    is a measure for the stripeness. Its minimum gives an</span>
<span class="sd">    estimate how to get the smoothest w data</span>
<span class="sd">    Args:</span>
<span class="sd">        w_radar_meanCol (ndarray): time series of mean Doppler velocity averaged over height with no nan values</span>
<span class="sd">        delta_t_min (float): minimum time shift</span>
<span class="sd">        delta_t_max (float): maximum time shift</span>
<span class="sd">        resolution (float): time step by which to increment possible time shift</span>
<span class="sd">        w_ship_chirp (ndarray): vertical velocity of the radar at the exact chirp time step</span>
<span class="sd">        timeSerieRadar (ndarray): time stamps of the mean Doppler velocity time series (w_radar_meanCol)</span>
<span class="sd">        pathFig (str): file path where figures should be stored</span>
<span class="sd">        chirp (int): which chirp is being processed</span>
<span class="sd">        hour (int): which hour of the day is being processed (0-23)</span>
<span class="sd">        date (datetime): which day is being processed</span>

<span class="sd">    Returns: time shift between radar data and ship data in seconds, quicklooks for each calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fontSizeTitle</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">fontSizeX</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">fontSizeY</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gcf</span><span class="p">()</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mf">0.15</span><span class="p">)</span>

    <span class="c1"># calculating variation for w_radar</span>
    <span class="n">w_prime_radar</span> <span class="o">=</span> <span class="n">w_radar_meanCol</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">w_radar_meanCol</span><span class="p">)</span>

    <span class="c1"># calculating covariance between w-ship and w_radar where w_ship is shifted for each deltaT given by DeltaTimeShift</span>
    <span class="n">DeltaTimeShift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">delta_t_min</span><span class="p">,</span> <span class="n">delta_t_max</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">resolution</span><span class="p">)</span>
    <span class="n">cov_ww</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DeltaTimeShift</span><span class="p">))</span>
    <span class="n">deltaW_ship</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DeltaTimeShift</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">DeltaTimeShift</span><span class="p">)):</span>
        <span class="c1"># calculate w_ship interpolating it on the new time array (timeShip+deltatimeShift(i))</span>
        <span class="n">T_corr</span> <span class="o">=</span> <span class="n">timeSerieRadar</span> <span class="o">+</span> <span class="n">DeltaTimeShift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># interpolating w_ship on the shifted time series</span>
        <span class="n">cs_ship</span> <span class="o">=</span> <span class="n">CubicSpline</span><span class="p">(</span><span class="n">timeSerieRadar</span><span class="p">,</span> <span class="n">w_ship_chirp</span><span class="p">)</span>
        <span class="n">w_ship_shifted</span> <span class="o">=</span> <span class="n">cs_ship</span><span class="p">(</span><span class="n">T_corr</span><span class="p">)</span>

        <span class="c1"># calculating w_prime_ship with the new interpolated series</span>
        <span class="n">w_ship_prime</span> <span class="o">=</span> <span class="n">w_ship_shifted</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">w_ship_shifted</span><span class="p">)</span>

        <span class="c1"># calculating covariance of the prime series</span>
        <span class="n">cov_ww</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">w_ship_prime</span> <span class="o">*</span> <span class="n">w_prime_radar</span><span class="p">)</span>

        <span class="c1"># calculating sharpness deltaW_ship</span>
        <span class="n">w_corrected</span> <span class="o">=</span> <span class="n">w_radar_meanCol</span> <span class="o">-</span> <span class="n">w_ship_shifted</span>
        <span class="n">delta_w</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">(</span><span class="n">w_corrected</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">deltaW_ship</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">delta_w</span><span class="p">)</span>

    <span class="c1"># calculating max of covariance and min of deltaW_ship</span>
    <span class="n">minDeltaW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">deltaW_ship</span><span class="p">)</span>
    <span class="n">indMin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">deltaW_ship</span> <span class="o">==</span> <span class="n">minDeltaW</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">maxCov_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">cov_ww</span><span class="p">)</span>
    <span class="n">indMax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cov_ww</span> <span class="o">==</span> <span class="n">maxCov_w</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Time shift found for chirp </span><span class="si">{</span><span class="n">chirp</span><span class="si">}</span><span class="s1"> at hour </span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">DeltaTimeShift</span><span class="p">[</span><span class="n">indMin</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># calculating time shift for radar data</span>
        <span class="n">timeShift_chirp</span> <span class="o">=</span> <span class="n">DeltaTimeShift</span><span class="p">[</span><span class="n">indMin</span><span class="p">]</span>
        <span class="c1"># if time shift is equal delta_t_min it&#39;s probably false -&gt; set it to 0</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">timeShift_chirp</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta_t_min</span><span class="p">):</span>
            <span class="n">timeShift_chirp</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># plot results</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;top&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">spines</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">tick_bottom</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">tick_left</span><span class="p">()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">DeltaTimeShift</span><span class="p">,</span> <span class="n">cov_ww</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;cov_ww&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">DeltaTimeShift</span><span class="p">[</span><span class="n">indMax</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;max cov_w&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">DeltaTimeShift</span><span class="p">,</span> <span class="n">deltaW_ship</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Deltaw^2&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">DeltaTimeShift</span><span class="p">[</span><span class="n">indMin</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;min Deltaw^2&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># ax.xaxis_date()</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)</span>  <span class="c1"># limits of the y-axesn  cmap=plt.cm.get_cmap(&quot;viridis&quot;, 256)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">delta_t_min</span><span class="p">,</span> <span class="n">delta_t_max</span><span class="p">)</span>  <span class="c1"># limits of the x-axes</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Covariance and Sharpiness for chirp </span><span class="si">{</span><span class="n">chirp</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s1">%Y-%m-%d</span><span class="si">}</span><span class="s1"> hour: </span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;time lag found : </span><span class="si">{</span><span class="n">DeltaTimeShift</span><span class="p">[</span><span class="n">indMin</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="n">fontsize</span><span class="o">=</span><span class="n">fontSizeTitle</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time Shift [seconds]&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontSizeX</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;w [m s$^{-1}$]&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="n">fontSizeY</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pathFig</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s1">%Y%m%d</span><span class="si">}</span><span class="s1">_timeShiftQuicklook_chirp</span><span class="si">{</span><span class="n">chirp</span><span class="si">}</span><span class="s1">_hour</span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s1">.png&#39;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;png&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Not enough data points for time shift calculation in chirp </span><span class="si">{</span><span class="n">chirp</span><span class="si">}</span><span class="s1"> at hour </span><span class="si">{</span><span class="n">hour</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
        <span class="n">timeShift_chirp</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">return</span> <span class="n">timeShift_chirp</span></div>


<div class="viewcode-block" id="calc_chirp_timestamps"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.calc_chirp_timestamps">[docs]</a><span class="k">def</span> <span class="nf">calc_chirp_timestamps</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">,</span> <span class="n">date</span><span class="p">,</span> <span class="n">version</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate the exact timestamp for each chirp corresponding with the center or start of the chirp</span>
<span class="sd">    The timestamp in the radar file corresponds to the end of a chirp sequence with an accuracy of 0.1 s</span>

<span class="sd">    Args:</span>
<span class="sd">        radar_ts (ndarray): timestamps of the radar with milliseconds in seconds</span>
<span class="sd">        date (datetime.datetime): date which is being processed</span>
<span class="sd">        version (str): should the timestamp correspond to the &#39;center&#39; or the &#39;start&#39; of the chirp</span>

<span class="sd">    Returns: dict with chirp timestamps</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make lookup table for chirp durations for each chirptable (see projekt1/remsens/hardware/LIMRAD94/chirptables)</span>
    <span class="n">chirp_durations</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">&quot;Chirp_No&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="s2">&quot;tradewindCU&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.022</span><span class="p">,</span> <span class="mf">0.947</span><span class="p">,</span> <span class="mf">0.966</span><span class="p">),</span>
                                    <span class="s2">&quot;Doppler1s&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.239</span><span class="p">,</span> <span class="mf">0.342</span><span class="p">,</span> <span class="mf">0.480</span><span class="p">),</span> <span class="s2">&quot;Cu_small_Tint&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.225</span><span class="p">,</span> <span class="mf">0.135</span><span class="p">,</span> <span class="mf">0.181</span><span class="p">),</span>
                                    <span class="s2">&quot;Cu_small_Tint2&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mf">0.562</span><span class="p">,</span> <span class="mf">0.572</span><span class="p">,</span> <span class="mf">0.453</span><span class="p">)})</span>
    <span class="c1"># calculate start time of each chirp by subtracting the duration of the later chirp(s) + the chirp itself</span>
    <span class="c1"># the timestamp then corresponds to the start of the chirp</span>
    <span class="c1"># select chirp durations according to date</span>
    <span class="k">if</span> <span class="n">date</span> <span class="o">&lt;</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">chirp_dur</span> <span class="o">=</span> <span class="n">chirp_durations</span><span class="p">[</span><span class="s2">&quot;tradewindCU&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">date</span> <span class="o">&lt;</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">chirp_dur</span> <span class="o">=</span> <span class="n">chirp_durations</span><span class="p">[</span><span class="s2">&quot;Doppler1s&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">date</span> <span class="o">&lt;</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">(</span><span class="mi">2020</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">chirp_dur</span> <span class="o">=</span> <span class="n">chirp_durations</span><span class="p">[</span><span class="s2">&quot;Cu_small_Tint&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chirp_dur</span> <span class="o">=</span> <span class="n">chirp_durations</span><span class="p">[</span><span class="s2">&quot;Cu_small_Tint2&quot;</span><span class="p">]</span>

    <span class="n">chirp_timestamps</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
        <span class="n">chirp_timestamps</span><span class="p">[</span><span class="s2">&quot;chirp_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radar_ts</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">chirp_timestamps</span><span class="p">[</span><span class="s2">&quot;chirp_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radar_ts</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">chirp_timestamps</span><span class="p">[</span><span class="s2">&quot;chirp_3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radar_ts</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chirp_timestamps</span><span class="p">[</span><span class="s2">&quot;chirp_1&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radar_ts</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">chirp_timestamps</span><span class="p">[</span><span class="s2">&quot;chirp_2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radar_ts</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">chirp_timestamps</span><span class="p">[</span><span class="s2">&quot;chirp_3&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">radar_ts</span> <span class="o">-</span> <span class="n">chirp_dur</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">chirp_timestamps</span></div>


<div class="viewcode-block" id="calc_shifted_chirp_timestamps"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.calc_shifted_chirp_timestamps">[docs]</a><span class="k">def</span> <span class="nf">calc_shifted_chirp_timestamps</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">,</span> <span class="n">radar_mdv</span><span class="p">,</span> <span class="n">chirp_ts</span><span class="p">,</span> <span class="n">rg_borders_id</span><span class="p">,</span> <span class="n">n_ts_run</span><span class="p">,</span> <span class="n">Cs_w_radar</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the time shift between each chirp time stamp and the ship time stamp for every hour and every chirp.</span>
<span class="sd">    Args:</span>
<span class="sd">        radar_ts (ndarray): radar time stamps in seconds (unix time)</span>
<span class="sd">        radar_mdv (ndarray): time x height matrix of mean Doppler velocity from radar</span>
<span class="sd">        chirp_ts (ndarray): exact chirp time stamps</span>
<span class="sd">        rg_borders_id (ndarray): indices of chirp boundaries</span>
<span class="sd">        n_ts_run (int): number of time steps necessary for mean Doppler velocity time series</span>
<span class="sd">        Cs_w_radar (scipy.interpolate.CubicSpline): function of vertical velocity of radar against time</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            no_chirps (int): number of chirps in radar measurement</span>
<span class="sd">            plot_fig (bool): plot quicklook</span>

<span class="sd">    Returns: time shifted chirp time stamps, array with time shifts for each chirp and hour</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">no_chirps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;no_chirps&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;no_chirps&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="mi">3</span>
    <span class="n">delta_t_min</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;delta_t_min&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;delta_t_min&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">radar_ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">radar_ts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">delta_t_max</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;delta_t_max&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;delta_t_max&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">radar_ts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">radar_ts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">resolution</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;resolution&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;resolution&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="mf">0.05</span>
    <span class="n">pathFig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;pathFig&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pathFig&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="s2">&quot;./tmp&quot;</span>
    <span class="n">date</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;date&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;date&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
    <span class="n">plot_fig</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;plot_fig&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;plot_fig&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="kc">False</span>

    <span class="n">time_shift_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">),</span> <span class="n">no_chirps</span><span class="p">))</span>
    <span class="n">chirp_ts_shifted</span> <span class="o">=</span> <span class="n">chirp_ts</span>
    <span class="c1"># get total hours in data and then loop through each hour</span>
    <span class="n">hours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">radar_ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">))</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">/</span> <span class="mi">60</span><span class="p">))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">)</span> <span class="o">/</span> <span class="n">hours</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hours</span><span class="p">):</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">idx</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hours</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="n">time_shift_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_chirps</span><span class="p">):</span>
            <span class="c1"># set time and range slice</span>
            <span class="n">ts_slice</span><span class="p">,</span> <span class="n">rg_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="n">rg_borders_id</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">rg_borders_id</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">mdv_slice</span> <span class="o">=</span> <span class="n">radar_mdv</span><span class="p">[</span><span class="n">ts_slice</span><span class="p">,</span> <span class="n">rg_slice</span><span class="p">]</span>
            <span class="n">time_slice</span> <span class="o">=</span> <span class="n">chirp_ts</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;chirp_</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span>
                <span class="n">ts_slice</span><span class="p">]</span>  <span class="c1"># select the corresponding exact chirp time for the mdv slice</span>
            <span class="n">mdv_series</span><span class="p">,</span> <span class="n">time_mdv_series</span><span class="p">,</span> <span class="n">height_id</span><span class="p">,</span> <span class="n">mdv_mean_col</span> <span class="o">=</span> <span class="n">find_mdv_time_series</span><span class="p">(</span><span class="n">mdv_slice</span><span class="p">,</span> <span class="n">time_slice</span><span class="p">,</span>
                                                                                        <span class="n">n_ts_run</span><span class="p">)</span>

            <span class="c1"># selecting w_radar values of the chirp over the same time interval as the mdv_series</span>
            <span class="n">w_radar_chirpSel</span> <span class="o">=</span> <span class="n">Cs_w_radar</span><span class="p">(</span><span class="n">time_mdv_series</span><span class="p">)</span>

            <span class="c1"># calculating time shift for the chirp and hour if at least n_ts_run measurements are available</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">mdv_mean_col</span><span class="p">))</span> <span class="o">==</span> <span class="n">n_ts_run</span><span class="p">:</span>
                <span class="n">time_shift_array</span><span class="p">[</span><span class="n">ts_slice</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_time_shift</span><span class="p">(</span><span class="n">mdv_mean_col</span><span class="p">,</span> <span class="n">delta_t_min</span><span class="p">,</span> <span class="n">delta_t_max</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span>
                                                                <span class="n">w_radar_chirpSel</span><span class="p">,</span> <span class="n">time_mdv_series</span><span class="p">,</span>
                                                                <span class="n">pathFig</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

            <span class="c1"># recalculate exact chirp time including time shift due to lag</span>
            <span class="n">chirp_ts_shifted</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;chirp_</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="n">ts_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">chirp_ts</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;chirp_</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="n">ts_slice</span><span class="p">]</span> <span class="o">-</span> <span class="n">time_shift_array</span><span class="p">[</span>
                <span class="n">ts_slice</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="c1"># get w_radar at the time shifted exact chirp time stamps</span>
            <span class="n">w_radar_exact</span> <span class="o">=</span> <span class="n">Cs_w_radar</span><span class="p">(</span><span class="n">chirp_ts_shifted</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;chirp_</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="n">ts_slice</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">plot_fig</span><span class="p">:</span>
                <span class="c1"># plot mdv time series and shifted radar heave rate</span>
                <span class="n">ts_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">argnearest</span><span class="p">(</span><span class="n">chirp_ts_shifted</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;chirp_</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="n">ts_slice</span><span class="p">],</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">time_mdv_series</span><span class="p">]</span>
                <span class="n">plot_time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">time_mdv_series</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                <span class="n">plot_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">time</span><span class="o">=</span><span class="n">plot_time</span><span class="p">,</span> <span class="n">mdv_mean_col</span><span class="o">=</span><span class="n">mdv_mean_col</span><span class="p">,</span>
                                            <span class="n">w_radar_org</span><span class="o">=</span><span class="n">Cs_w_radar</span><span class="p">(</span><span class="n">time_mdv_series</span><span class="p">),</span>
                                            <span class="n">w_radar_chirpSel</span><span class="o">=</span><span class="n">w_radar_chirpSel</span><span class="p">,</span>
                                            <span class="n">w_radar_exact_shifted</span><span class="o">=</span><span class="n">w_radar_exact</span><span class="p">[</span><span class="n">ts_idx</span><span class="p">]))</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span>
                <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plot_df</span><span class="p">[</span><span class="s1">&#39;mdv_mean_col&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;mean mdv over column at original radar time&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plot_df</span><span class="p">[</span><span class="s1">&#39;w_radar_org&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;w_radar at original radar time&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plot_df</span><span class="p">[</span><span class="s1">&#39;w_radar_chirpSel&#39;</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;w_radar at original chirp time&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">plot_df</span><span class="p">[</span><span class="s1">&#39;w_radar_exact_shifted&#39;</span><span class="p">],</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;w_radar shifted&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">4.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">frameon</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="c1"># limits of the y-axesn  cmap=plt.cm.get_cmap(&quot;viridis&quot;, 256)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Velocity for Time Delay Calculations : </span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s1">%Y-%m-%d</span><span class="si">}</span><span class="s1"> shift = </span><span class="si">{</span><span class="n">time_shift_array</span><span class="p">[</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time [day hh:mm]&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;w [m s$^{-1}$]&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">xaxis_date</span><span class="p">()</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">autofmt_xdate</span><span class="p">()</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">pathFig</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="n">date</span><span class="si">:</span><span class="s1">%Y%m%d</span><span class="si">}</span><span class="s1">_time-series_mdv_w-radar_chirp</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">_hour</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">.png&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">chirp_ts_shifted</span><span class="p">,</span> <span class="n">time_shift_array</span></div>


<div class="viewcode-block" id="calc_corr_matrix_claudia"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.calc_corr_matrix_claudia">[docs]</a><span class="k">def</span> <span class="nf">calc_corr_matrix_claudia</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">,</span> <span class="n">radar_rg</span><span class="p">,</span> <span class="n">rg_borders_id</span><span class="p">,</span> <span class="n">chirp_ts_shifted</span><span class="p">,</span> <span class="n">Cs_w_radar</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the correction matrix to correct the mean Doppler velocity for the ship vertical motion.</span>
<span class="sd">    Args:</span>
<span class="sd">        radar_ts (ndarray): original radar time stamps in seconds (unix time)</span>
<span class="sd">        radar_rg (ndarray): radar range gates</span>
<span class="sd">        rg_borders_id (ndarray): indices of chirp boundaries</span>
<span class="sd">        chirp_ts_shifted (dict): hourly shifted chirp time stamps</span>
<span class="sd">        Cs_w_radar (scipy.interpolate.CubicSpline): function of vertical velocity of radar against time</span>

<span class="sd">    Returns: correction matrix for mean Doppler velocity</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">no_chirps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chirp_ts_shifted</span><span class="p">)</span>
    <span class="n">corr_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">radar_rg</span><span class="p">)))</span>
    <span class="c1"># get total hours in data and then loop through each hour</span>
    <span class="n">hours</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">radar_ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">))</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">/</span> <span class="mi">60</span><span class="p">))</span>
    <span class="c1"># divide the day in equal hourly slices</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">)</span> <span class="o">/</span> <span class="n">hours</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">hours</span><span class="p">):</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">idx</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hours</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">radar_ts</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_chirps</span><span class="p">):</span>
            <span class="c1"># set time and range slice</span>
            <span class="n">ts_slice</span><span class="p">,</span> <span class="n">rg_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="p">),</span> <span class="nb">slice</span><span class="p">(</span><span class="n">rg_borders_id</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">rg_borders_id</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># get w_radar at the time shifted exact chirp time stamps</span>
            <span class="n">w_radar_exact</span> <span class="o">=</span> <span class="n">Cs_w_radar</span><span class="p">(</span><span class="n">chirp_ts_shifted</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;chirp_</span><span class="si">{</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">][</span><span class="n">ts_slice</span><span class="p">])</span>
            <span class="c1"># add a dimension to w_radar_exact and repeat it over this dimension (range) to fill the hour and</span>
            <span class="c1"># chirp of the correction array</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">w_radar_exact</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">rg_borders_id</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">rg_borders_id</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">corr_matrix</span><span class="p">[</span><span class="n">ts_slice</span><span class="p">,</span> <span class="n">rg_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>

    <span class="k">return</span> <span class="n">corr_matrix</span></div>


<div class="viewcode-block" id="get_range_bin_borders"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.get_range_bin_borders">[docs]</a><span class="k">def</span> <span class="nf">get_range_bin_borders</span><span class="p">(</span><span class="n">no_chirps</span><span class="p">,</span> <span class="n">container</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;get the range bins which correspond to the chirp borders of a FMCW radar</span>

<span class="sd">    Args:</span>
<span class="sd">        no_chirps (int): Number of chirps</span>
<span class="sd">        container (dict): Dictionary with C1/2/3Range variable from LV1 files</span>

<span class="sd">    Returns: </span>
<span class="sd">        ndarray with chirp borders including 0 range_bins</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">range_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">no_chirps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>  <span class="c1"># needs to be length 4 to include all +1 chirp borders</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_chirps</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">range_bins</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">container</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;C</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">Range&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># in case only one file is read in data[&quot;C1Range&quot;][&quot;var&quot;] has only one dimension</span>
            <span class="n">range_bins</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">range_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">container</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;C</span><span class="si">{</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s1">Range&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">return</span> <span class="n">range_bins</span></div>


<div class="viewcode-block" id="calc_heave_corr"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.calc_heave_corr">[docs]</a><span class="k">def</span> <span class="nf">calc_heave_corr</span><span class="p">(</span><span class="n">container</span><span class="p">,</span> <span class="n">chirp_ts</span><span class="p">,</span> <span class="n">seapath</span><span class="p">,</span> <span class="n">mean_hr</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate heave correction for mean Doppler velocity</span>

<span class="sd">    Args:</span>
<span class="sd">        container (larda container): LIMRAD94 C1/2/3_Range, SeqIntTime, ts</span>
<span class="sd">        chirp_ts (dict): dictionary with exact radar chirp time stamps</span>
<span class="sd">        seapath (pd.DataFrame): Data frame with heave rate column (&quot;heave_rate_radar&quot;)</span>
<span class="sd">        mean_hr (bool): whether to use the mean heave rate over the SeqIntTime or the heave rate at the start time of the chirp</span>

<span class="sd">    Returns: </span>
<span class="sd">        heave_corr (ndarray): heave rate closest to each radar timestep for each height bin, time x range</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1">####################################################################################################################</span>
    <span class="c1"># Calculating Timestamps for each chirp</span>
    <span class="c1">####################################################################################################################</span>
    <span class="c1"># array with range bin numbers of chirp borders</span>
    <span class="n">no_chirps</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chirp_ts</span><span class="p">)</span>
    <span class="n">range_bins</span> <span class="o">=</span> <span class="n">get_range_bin_borders</span><span class="p">(</span><span class="n">no_chirps</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="n">seapath_ts</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span>  <span class="c1"># convert datetime index to seconds since 1970-01-01</span>
    <span class="n">total_range_bins</span> <span class="o">=</span> <span class="n">range_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># get total number of range bins</span>
    <span class="c1"># initialize output variables</span>
    <span class="n">heave_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">container</span><span class="p">[</span><span class="s2">&quot;ts&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">total_range_bins</span><span class="p">))</span>  <span class="c1"># time x range</span>
    <span class="n">seapath_out</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_chirps</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># get integration time for chirp</span>
        <span class="n">int_time</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">container</span><span class="p">[</span><span class="s1">&#39;SeqIntTime&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="c1"># convert timestamps of moments to array</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">chirp_ts</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;chirp_</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">id_diff_mins</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize list for indices of the time steps with minimum difference</span>
        <span class="n">means_ls</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize list for means over integration time for each radar time step</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
            <span class="n">id_diff_min</span> <span class="o">=</span> <span class="n">argnearest</span><span class="p">(</span><span class="n">seapath_ts</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># find index of nearest seapath time step to radar time step</span>
            <span class="n">id_diff_mins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">id_diff_min</span><span class="p">)</span>
            <span class="c1"># get time stamp of closest index</span>
            <span class="n">ts_id_diff_min</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">id_diff_min</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">mean_hr</span><span class="p">:</span>
                <span class="c1"># select rows from closest time stamp to end of integration time and average, append to list</span>
                <span class="n">means_ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seapath</span><span class="p">[</span><span class="n">ts_id_diff_min</span><span class="p">:</span><span class="n">ts_id_diff_min</span><span class="o">+</span><span class="n">int_time</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">means_ls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seapath</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ts_id_diff_min</span><span class="p">])</span>

        <span class="c1"># concatenate all means into one dataframe with the original header (transpose)</span>
        <span class="n">seapath_closest</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">means_ls</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># add index with closest seapath time step to radar time step</span>
        <span class="n">seapath_closest</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">id_diff_mins</span><span class="p">]</span>

        <span class="c1"># check if heave rate is greater than 5 standard deviations away from the daily mean and filter those values</span>
        <span class="c1"># by averaging the step before and after</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">seapath_closest</span><span class="p">[</span><span class="s2">&quot;heave_rate_radar&quot;</span><span class="p">])</span>
        <span class="c1"># try to get indices from values which do not pass the filter. If that doesn&#39;t work, then there are no values</span>
        <span class="c1"># which don&#39;t pass the filter and a ValueError is raised. Write this to a logger</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">id_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">seapath_closest</span><span class="p">[</span><span class="s2">&quot;heave_rate_radar&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">std</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">id_max</span><span class="p">)):</span>
                <span class="n">idc</span> <span class="o">=</span> <span class="n">id_max</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Heave rate greater 5 * std encountered (</span><span class="si">{</span><span class="n">seapath_closest</span><span class="p">[</span><span class="s1">&#39;heave_rate_radar&#39;</span><span class="p">][</span><span class="n">idc</span><span class="p">]</span><span class="si">}</span><span class="s2">)! </span><span class="se">\n</span><span class="s2">&quot;</span>
                              <span class="sa">f</span><span class="s2">&quot;Using average of step before and after. Index: </span><span class="si">{</span><span class="n">idc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
                <span class="n">avg_hrate</span> <span class="o">=</span> <span class="p">(</span><span class="n">seapath_closest</span><span class="p">[</span><span class="s2">&quot;heave_rate_radar&quot;</span><span class="p">][</span><span class="n">idc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">seapath_closest</span><span class="p">[</span><span class="s2">&quot;heave_rate_radar&quot;</span><span class="p">][</span><span class="n">idc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">avg_hrate</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">std</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Heave Rate value greater than 5 * std encountered (</span><span class="si">{</span><span class="n">avg_hrate</span><span class="si">}</span><span class="s2">)! </span><span class="se">\n</span><span class="s2">&quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;Even after averaging step before and after too high value! Index: </span><span class="si">{</span><span class="n">idc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                                  <span class="ne">UserWarning</span><span class="p">)</span>
                <span class="n">seapath_closest</span><span class="p">[</span><span class="s2">&quot;heave_rate_radar&quot;</span><span class="p">][</span><span class="n">idc</span><span class="p">]</span> <span class="o">=</span> <span class="n">avg_hrate</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;All heave rate values are within 5 standard deviation of the daily mean!&quot;</span><span class="p">)</span>

        <span class="c1"># add column with chirp number to distinguish in quality control</span>
        <span class="n">seapath_closest</span><span class="p">[</span><span class="s2">&quot;Chirp_no&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seapath_closest</span><span class="o">.</span><span class="n">index</span><span class="p">))</span>
        <span class="c1"># make data frame with used heave rates</span>
        <span class="n">seapath_out</span> <span class="o">=</span> <span class="n">seapath_out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">seapath_closest</span><span class="p">)</span>
        <span class="c1"># create array with same dimensions as velocity (time, range)</span>
        <span class="n">heave_rate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">seapath_closest</span><span class="p">[</span><span class="s2">&quot;heave_rate_radar&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># duplicate the heave correction over the range dimension to add it to all range bins of the chirp</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">range_bins</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">range_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">heave_corr</span><span class="p">[:,</span> <span class="n">range_bins</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">range_bins</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">heave_rate</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculated heave correction for Chirp </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t1</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with heave correction calculation in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">heave_corr</span><span class="p">,</span> <span class="n">seapath_out</span></div>


<div class="viewcode-block" id="calc_dopp_res"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.calc_dopp_res">[docs]</a><span class="k">def</span> <span class="nf">calc_dopp_res</span><span class="p">(</span><span class="n">MaxVel</span><span class="p">,</span> <span class="n">DoppLen</span><span class="p">,</span> <span class="n">no_chirps</span><span class="p">,</span> <span class="n">range_bins</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        MaxVel (ndarray): Unambiguous Doppler velocity (+/-) m/s from LV1 file</span>
<span class="sd">        DoppLen (ndarray): Number of spectral lines in Doppler spectra from LV1 file</span>
<span class="sd">        no_chirps (int): Number of chirps</span>
<span class="sd">        range_bins (ndarray): range bin number of lower chirp borders, starts with 0</span>

<span class="sd">    Returns: </span>
<span class="sd">        1D array with Doppler resolution for each height bin</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DoppRes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">MaxVel</span><span class="p">,</span> <span class="n">DoppLen</span><span class="p">)</span>
    <span class="n">dopp_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">range_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no_chirps</span><span class="p">):</span>
        <span class="n">dopp_res</span><span class="p">[</span><span class="n">range_bins</span><span class="p">[</span><span class="n">ic</span><span class="p">]:</span><span class="n">range_bins</span><span class="p">[</span><span class="n">ic</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">DoppRes</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">dopp_res</span></div>


<div class="viewcode-block" id="heave_rate_to_spectra_bins"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.heave_rate_to_spectra_bins">[docs]</a><span class="k">def</span> <span class="nf">heave_rate_to_spectra_bins</span><span class="p">(</span><span class="n">heave_corr</span><span class="p">,</span> <span class="n">doppler_res</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;translate the heave correction to Doppler spectra bins</span>

<span class="sd">    Args:</span>
<span class="sd">        heave_corr (ndarray): heave rate closest to each radar timestep for each height bin, time x range</span>
<span class="sd">        doppler_res (ndarray): Doppler resolution of each chirp of LIMRAD94 for whole range 1 x range</span>

<span class="sd">    Returns: </span>
<span class="sd">        ndarray with number of bins to move each Doppler spectrum</span>
<span class="sd">        </span>
<span class="sd">        - **n_dopp_bins_shift** (*ndarray*): of same dimension as heave_corr</span>
<span class="sd">        - **heave_corr**</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># add a dimension to the doppler_res vector</span>
    <span class="n">doppler_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">doppler_res</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># repeat doppler_res to same time dimension as heave_corr</span>
    <span class="n">doppler_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">doppler_res</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">heave_corr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">doppler_res</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">heave_corr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Arrays have different shape! </span><span class="si">{</span><span class="n">doppler_res</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> &quot;</span> \
                                                  <span class="sa">f</span><span class="s2">&quot;and </span><span class="si">{</span><span class="n">heave_corr</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># calculate number of Doppler bins</span>
    <span class="n">n_dopp_bins_shift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">heave_corr</span> <span class="o">/</span> <span class="n">doppler_res</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with translation of heave corrections to Doppler bins in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">n_dopp_bins_shift</span><span class="p">,</span> <span class="n">heave_corr</span></div>


<div class="viewcode-block" id="shift_seapath"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.shift_seapath">[docs]</a><span class="k">def</span> <span class="nf">shift_seapath</span><span class="p">(</span><span class="n">seapath</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Shift seapath values by given shift</span>

<span class="sd">    Args:</span>
<span class="sd">        seapath (pd.Dataframe): Dataframe with heave motion of RV-Meteor</span>
<span class="sd">        shift (int): number of time steps to shift data</span>

<span class="sd">    Returns: </span>
<span class="sd">        shifted Dataframe</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shifting seapath data by </span><span class="si">{</span><span class="n">shift</span><span class="si">}</span><span class="s2"> time steps.&quot;</span><span class="p">)</span>
    <span class="c1"># get day of seapath data</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># shift seapath data by shift</span>
    <span class="n">seapath_shifted</span> <span class="o">=</span> <span class="n">seapath</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">periods</span><span class="o">=</span><span class="n">shift</span><span class="p">)</span>

    <span class="c1"># replace Nans at start with data from the previous day or from following day</span>
    <span class="k">if</span> <span class="n">shift</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">dt_previous</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># get date of previous day</span>
        <span class="n">skiprows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seapath</span><span class="p">)</span> <span class="o">-</span> <span class="n">shift</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># define rows to skip on read in</span>
        <span class="c1"># read in one more row for heave rate calculation</span>
        <span class="n">seapath_previous</span> <span class="o">=</span> <span class="n">read_seapath</span><span class="p">(</span><span class="n">dt_previous</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">shift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="n">skiprows</span><span class="p">)</span>
        <span class="n">seapath_previous</span> <span class="o">=</span> <span class="n">calc_heave_rate</span><span class="p">(</span><span class="n">seapath_previous</span><span class="p">)</span>
        <span class="n">seapath_previous</span> <span class="o">=</span> <span class="n">seapath_previous</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>  <span class="c1"># remove first row (=nan)</span>
        <span class="c1"># remove index and replace with index from original data frame</span>
        <span class="n">seapath_previous</span> <span class="o">=</span> <span class="n">seapath_previous</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">seapath_shifted</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">shift</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">seapath_shifted</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">seapath_previous</span><span class="p">)</span>  <span class="c1"># overwrite nan values in shifted data frame</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dt_following</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">+</span> <span class="n">datetime</span><span class="o">.</span><span class="n">timedelta</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># get date from following day</span>
        <span class="n">seapath_following</span> <span class="o">=</span> <span class="n">read_seapath</span><span class="p">(</span><span class="n">dt_following</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shift</span><span class="p">))</span>
        <span class="n">seapath_following</span> <span class="o">=</span> <span class="n">calc_heave_rate</span><span class="p">(</span><span class="n">seapath_following</span><span class="p">)</span>
        <span class="c1"># overwrite nan values</span>
        <span class="c1"># leaves in one NaN value because the heave rate of the first time step of a day cannot be calculated</span>
        <span class="c1"># one nan is better than many (shift) though, so this is alright</span>
        <span class="n">seapath_following</span> <span class="o">=</span> <span class="n">seapath_following</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="n">seapath_shifted</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">shift</span><span class="p">:,</span> <span class="p">:]</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">seapath_shifted</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">seapath_following</span><span class="p">)</span>  <span class="c1"># overwrite nan values in shifted data frame</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done with shifting seapath data, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span><span class="si">}</span><span class="s2"> [min:sec]&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">seapath_shifted</span></div>


<div class="viewcode-block" id="find_closest_timesteps"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.find_closest_timesteps">[docs]</a><span class="k">def</span> <span class="nf">find_closest_timesteps</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">ts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find closest time steps in a dataframe to a time series</span>

<span class="sd">    Args:</span>
<span class="sd">        df (pd.DataFrame): DataFrame with DatetimeIndex</span>
<span class="sd">        ts (ndarray): array with time stamps in unix format (seconds since 1-1-1970)</span>

<span class="sd">    Returns: </span>
<span class="sd">        pd.DataFrame with only the closest time steps to ts</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">inferred_type</span> <span class="o">==</span> <span class="s1">&#39;datetime64&#39;</span><span class="p">,</span> <span class="s2">&quot;Dataframe Index is not a DatetimeIndex trying to turn into one&quot;</span>
    <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">infer_datetime_format</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">df_ts</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">9</span>  <span class="c1"># convert datetime index to seconds since 1970-01-01</span>
    <span class="n">df_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># initialize lsit to append df rows closest to input time steps to</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">ts</span><span class="p">:</span>
        <span class="n">id_diff_min</span> <span class="o">=</span> <span class="n">argnearest</span><span class="p">(</span><span class="n">df_ts</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>  <span class="c1"># find index of nearest dship time step to input time step</span>
        <span class="n">ts_id_diff_min</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="n">id_diff_min</span><span class="p">]</span>  <span class="c1"># get time stamp of closest index</span>
        <span class="n">df_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ts_id_diff_min</span><span class="p">])</span>  <span class="c1"># append row to list</span>

    <span class="c1"># concatenate all rows into one dataframe with the original header (transpose)</span>
    <span class="n">df_closest</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df_list</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Done finding closest time steps in </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df_closest</span></div>


<div class="viewcode-block" id="spectra2sldr"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.spectra2sldr">[docs]</a><span class="k">def</span> <span class="nf">spectra2sldr</span><span class="p">(</span><span class="n">ZSpec</span><span class="p">,</span> <span class="n">paraminfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine calculates the</span>

<span class="sd">    Args:</span>
<span class="sd">        ZSpec (dict): list containing the dicts for each chrip of RPG-FMCW Doppler cloud radar</span>
<span class="sd">        paraminfo (dict): information from params_[campaign].toml for the system LIMRAD94</span>

<span class="sd">    Returns:</span>
<span class="sd">        container_dict (dict): dictionary of larda containers, including larda container for Ze, VEL, sw, skew, kurt</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>  <span class="c1"># initialize variables:</span>

    <span class="n">tspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># - ZSpec[iC][&#39;mean&#39;]</span>
    <span class="n">hspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;HSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">tspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;thresh&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># - ZSpec[iC][&#39;mean&#39;]</span>
    <span class="n">vspec_lin</span> <span class="o">=</span> <span class="n">tspec_lin</span> <span class="o">-</span> <span class="n">hspec_lin</span>
    <span class="n">Revhspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;ReVHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Imvhspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;ImVHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vspec_lin</span><span class="p">[</span><span class="n">vspec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">hspec_lin</span><span class="p">[</span><span class="n">hspec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">Revhspec_lin</span><span class="p">[</span><span class="n">Revhspec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">Imvhspec_lin</span><span class="p">[</span><span class="n">Imvhspec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">vhspec_complex</span> <span class="o">=</span> <span class="n">Revhspec_lin</span> <span class="o">+</span> <span class="n">Imvhspec_lin</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">vspec_lin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

        <span class="n">Zt</span> <span class="o">=</span> <span class="n">tspec_lin</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">Zh</span> <span class="o">=</span> <span class="n">hspec_lin</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">Zre</span> <span class="o">=</span> <span class="n">Revhspec_lin</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="n">Zim</span> <span class="o">=</span> <span class="n">Imvhspec_lin</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>


    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ZT  = double(ncread(filename,[&#39;C&#39; num2str(i) &#39;VSpec&#39;]));    % In the case of STSR mode, this variable contains the combined reflectivity spectrum</span>
<span class="sd">        ZH  = double(ncread(filename,[&#39;C&#39; num2str(i) &#39;HSpec&#39;]));    % Spectrum in the horizontal channel</span>
<span class="sd">        ZRE = double(ncread(filename,[&#39;C&#39; num2str(i) &#39;ReVHSpec&#39;])); % Real part of the covariance spectrum</span>
<span class="sd">        ZIM = double(ncread(filename,[&#39;C&#39; num2str(i) &#39;ImVHSpec&#39;])); % Imaginary part of the covariance spectrum</span>
<span class="sd">        </span>
<span class="sd">        NV  = double(ncread(filename,[&#39;C&#39; num2str(i) &#39;VNoisePow&#39;])); % Integrated noise in the vertical channel</span>
<span class="sd">        NH  = double(ncread(filename,[&#39;C&#39; num2str(i) &#39;HNoisePow&#39;])); % Integrated noise in the horizontal channel</span>
<span class="sd">        </span>
<span class="sd">        SLDR = zeros(size(ZT,2),size(ZT,3)) * NaN;</span>
<span class="sd">        </span>
<span class="sd">        for j = 1:size(ZT,3)</span>
<span class="sd">            </span>
<span class="sd">            Zt = ZT(:,:,j);</span>
<span class="sd">            Zh = ZH(:,:,j);</span>
<span class="sd">            Zre = ZRE(:,:,j);</span>
<span class="sd">            Zim = ZIM(:,:,j);</span>
<span class="sd">            </span>
<span class="sd">            Nv = NV(:,j);</span>
<span class="sd">            Nh = NH(:,j);</span>
<span class="sd">        </span>
<span class="sd">            if SW &gt;= 540</span>
<span class="sd">                Zv = 4 * Zt - Zh - 2 * Zre; % Starting from the software version 5.40, the combined spectrum is normalized by 4</span>
<span class="sd">            else</span>
<span class="sd">                Zv = 2 * Zt - Zh - 2 * Zre; % In the previous versions the combined spectrum was normalized by 2</span>
<span class="sd">            end</span>

<span class="sd">            clear Zt</span>

<span class="sd">            Nfft = size(Zv,1); % Number of spectral lines</span>

<span class="sd">            Nv = Nv/Nfft; % Spectral noise power in each spectral bin</span>
<span class="sd">            Nh = Nh/Nfft; % Spectral noise power in each spectral bin</span>

<span class="sd">            Nv = repmat(Nv,1,Nfft)&#39;;</span>
<span class="sd">            Nh = repmat(Nh,1,Nfft)&#39;;</span>

<span class="sd">            % Method based on Galletti et al. 2011</span>

<span class="sd">            % According to (10) in the Galletti&#39;s paper the depolarization</span>
<span class="sd">            % ratio can be calculated from the degree of polarization in the </span>
<span class="sd">            % case of the reflectio symmetry. In the case of vertical</span>
<span class="sd">            % observations the assumption is typically reasonable. The</span>
<span class="sd">            % assumption is sometimes not applicable in thunderstorm clouds,</span>
<span class="sd">            % where electrical activity can allign ice particles in a certain</span>
<span class="sd">            % direction. This formula also cannot be used at lower elevation</span>
<span class="sd">            % angles since liquid and  ice particles tend to orient</span>
<span class="sd">            % horizontally.</span>

<span class="sd">            % In the STSR radars the degree of polarization is related to the</span>
<span class="sd">            % correlation coefficient (see eq. (12) in Galletti and Zrnic 2012).</span>
<span class="sd">            % In the case of vertical observations ZDR is most of the time 1</span>
<span class="sd">            % (or 0 dB). In this case the degree of polarization is equal to</span>
<span class="sd">            % the correlation coefficient. Thus, in the eq. (10) in the</span>
<span class="sd">            % Galletti&#39;s paper we can use the correlation coefficient instead</span>
<span class="sd">            % of the degree of polarization.</span>

<span class="sd">            % The main disadvantage of this method is that it does not take into</span>
<span class="sd">            % account that we have signal + noise and we are only interested in</span>
<span class="sd">            % the depolarization ratio of the signal. In other words, if SNR is</span>
<span class="sd">            % low, there will be strong apparent depolarization caused by noise.</span>
<span class="sd">            % In order to avoid this, I have introduced the threshold of 30 dB.</span>
<span class="sd">            % The 30 dB threshold has been chosen because this is typically the</span>
<span class="sd">            % level of polarimetric coupling in the good antennas of</span>
<span class="sd">            % meteorological radars.</span>

<span class="sd">            SNRv = Zv./Nv;</span>
<span class="sd">            SNRh = Zh./Nh;</span>

<span class="sd">            % Spectral lines with less than 30 dB SNR are replaced by NaN</span>
<span class="sd">            % values</span>
<span class="sd">            k = find((SNRv &lt; 1000) | (SNRh &lt; 1000));</span>

<span class="sd">            Zv(k) = NaN;</span>
<span class="sd">            Zh(k) = NaN;</span>
<span class="sd">            Zre(k) = NaN;</span>
<span class="sd">            Zim(k) = NaN;</span>

<span class="sd">            Nv(k) = NaN;</span>
<span class="sd">            Nh(k) = NaN;</span>

<span class="sd">            clear k SNRv SNRh</span>

<span class="sd">            Zv = squeeze(nansum(Zv));</span>
<span class="sd">            Zh = squeeze(nansum(Zh));</span>
<span class="sd">            Zre = squeeze(nansum(Zre));</span>
<span class="sd">            Zim = squeeze(nansum(Zim));</span>

<span class="sd">            Nv = squeeze(nansum(Nv));</span>
<span class="sd">            Nh = squeeze(nansum(Nh));</span>
<span class="sd">            </span>
<span class="sd">            k = find((Zv ==0) | (Zh == 0));</span>
<span class="sd">            </span>
<span class="sd">            Zv(k) = NaN;</span>
<span class="sd">            Zh(k) = NaN;</span>
<span class="sd">            Zre(k) = NaN;</span>
<span class="sd">            Zim(k) = NaN;</span>

<span class="sd">            rhv  = abs(Zre+1i*Zim)./sqrt((Zv+Nv).*(Zh+Nh)); % Correlation coefficient for each spectral bin</span>
<span class="sd">            sldr = ((1-rhv)./(1+rhv));                      % Depolarization ratio according to (10)</span>

<span class="sd">            sldr = single(sldr);</span>
<span class="sd">            </span>
<span class="sd">            SLDR(:,j) = sldr&#39;;</span>
<span class="sd">            </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Polarimetric spectra &amp; products calculated, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pol</span></div>



<div class="viewcode-block" id="spectra2polarimetry"><a class="viewcode-back" href="../../spectra.html#pyLARDA.SpectraProcessing.spectra2polarimetry">[docs]</a><span class="k">def</span> <span class="nf">spectra2polarimetry</span><span class="p">(</span><span class="n">ZSpec</span><span class="p">,</span> <span class="n">paraminfo</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This routine calculates the</span>

<span class="sd">    Args:</span>
<span class="sd">        ZSpec (dict): list containing the dicts for each chrip of RPG-FMCW Doppler cloud radar</span>
<span class="sd">        paraminfo (dict): information from params_[campaign].toml for the system LIMRAD94</span>

<span class="sd">    Returns:</span>
<span class="sd">        container_dict (dict): dictionary of larda containers, including larda container for Ze, VEL, sw, skew, kurt</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">tstart</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>  <span class="c1"># initialize variables:</span>

    <span class="n">vspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;VHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># - ZSpec[iC][&#39;mean&#39;]</span>
    <span class="n">hspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;HSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vspec_lin</span> <span class="o">=</span> <span class="n">vspec_lin</span> <span class="o">-</span> <span class="n">hspec_lin</span>
    <span class="n">Revhspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;ReVHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">Imvhspec_lin</span> <span class="o">=</span> <span class="n">ZSpec</span><span class="p">[</span><span class="s1">&#39;ImVHSpec&#39;</span><span class="p">][</span><span class="s1">&#39;var&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">vspec_lin</span><span class="p">[</span><span class="n">vspec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">hspec_lin</span><span class="p">[</span><span class="n">hspec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">Revhspec_lin</span><span class="p">[</span><span class="n">Revhspec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">Imvhspec_lin</span><span class="p">[</span><span class="n">Imvhspec_lin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="n">vhspec_complex</span> <span class="o">=</span> <span class="n">Revhspec_lin</span> <span class="o">+</span> <span class="n">Imvhspec_lin</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span>

    <span class="n">ZDR</span> <span class="o">=</span> <span class="n">vspec_lin</span> <span class="o">/</span> <span class="n">hspec_lin</span>
    <span class="n">rhoVH</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">vhspec_complex</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">vspec_lin</span> <span class="o">*</span> <span class="n">hspec_lin</span><span class="p">)</span>
    <span class="n">phiDP</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">vhspec_complex</span><span class="p">)</span>
    <span class="n">tmp1</span> <span class="o">=</span> <span class="n">vspec_lin</span> <span class="o">+</span> <span class="n">hspec_lin</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Revhspec_lin</span>
    <span class="n">tmp2</span> <span class="o">=</span> <span class="n">vspec_lin</span> <span class="o">+</span> <span class="n">hspec_lin</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Revhspec_lin</span>
    <span class="n">SLDR</span> <span class="o">=</span> <span class="n">tmp1</span> <span class="o">/</span> <span class="n">tmp2</span>
    <span class="n">CORR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">vspec_lin</span> <span class="o">-</span> <span class="n">hspec_lin</span> <span class="o">+</span> <span class="mi">2</span><span class="n">j</span> <span class="o">*</span> <span class="n">Imvhspec_lin</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tmp1</span> <span class="o">*</span> <span class="n">tmp2</span><span class="p">)</span>

    <span class="n">pol</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ZDR_s&#39;</span><span class="p">:</span> <span class="n">ZDR</span><span class="p">,</span> <span class="s1">&#39;ZDR&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">ZDR</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
           <span class="s1">&#39;rhoVH_s&#39;</span><span class="p">:</span> <span class="n">rhoVH</span><span class="p">,</span> <span class="s1">&#39;rhoVH&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">rhoVH</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
           <span class="s1">&#39;phiDP_s&#39;</span><span class="p">:</span> <span class="n">phiDP</span><span class="p">,</span> <span class="s1">&#39;phiDP&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">phiDP</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
           <span class="s1">&#39;ldr_s&#39;</span><span class="p">:</span> <span class="n">SLDR</span><span class="p">,</span> <span class="s1">&#39;ldr&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">SLDR</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span>
           <span class="s1">&#39;CORR_s&#39;</span><span class="p">:</span> <span class="n">CORR</span><span class="p">,</span> <span class="s1">&#39;CORR&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">CORR</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
           <span class="p">}</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Polarimetric spectra &amp; products calculated, elapsed time = </span><span class="si">{</span><span class="n">seconds_to_fstring</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">tstart</span><span class="p">)</span><span class="si">}</span><span class="s1"> [min:sec]&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pol</span></div>

</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020 pyLARDA-dev-team

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>